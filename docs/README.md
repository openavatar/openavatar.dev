# ç®€ä»‹

## ä»€ä¹ˆæ˜¯ OpenAvatar-SDK ?

OpenAvatar æ˜¯å…¨çƒç¬¬ä¸€ä¸ªå¯è§†åŒ– Web3 DIDåè®®

OpenAvatar-SDK æ˜¯ OPENAVATAR çš„ä¸€ä¸ªå¼€æºç»„ä»¶ï¼Œå®ƒæ˜¯ä»Privatepartyåº“æ´¾ç”Ÿçš„å¼€æºæ¡†æ¶ï¼Œå¯ä»¥éå¸¸å®¹æ˜“åœ°æ„å»ºåŒºå—é“¾è®¤è¯çš„ Web3 åº”ç”¨ç¨‹åºã€‚

åªéœ€å‡ è¡Œä»£ç ï¼Œå³å¯ä»¥æ­å»ºå‡ºå…·æœ‰å¤æ‚(é’±åŒ…èº«ä»½éªŒè¯/æˆæƒ)é€»è¾‘çš„ Web3 åº”ç”¨ç¨‹åºã€‚

![ppclient.png](ppclient.png)

ç»“æœå¦‚ä¸‹ï¼š

![login.gif](login.gif)


1. **èº«ä»½éªŒè¯ï¼š** ä½¿ç”¨åŒºå—é“¾é’±åŒ…ç­¾åç™»å½•
2. **æˆæƒï¼š** æ ¹æ®åŒºå—é“¾çŠ¶æ€æˆ–é“¾ä¸‹æŸ¥è¯¢æˆæƒè®¿é—®æ‚¨çš„é¡µé¢
3. **ç®€å•ï¼š** åªéœ€ä¸€è¡Œ JavaScript ä»£ç å³å¯è®¾ç½®ã€‚ æ²¡æœ‰å¤æ‚çš„æ­¥éª¤ã€‚
4. **å¼€æºï¼š** 100% å¼€æºæ¡†æ¶ï¼Œæ²¡æœ‰ç¬¬ä¸‰æ–¹APIã€‚

## OpenAvatar-SDK èƒ½åšä»€ä¹ˆ?

OpenAvatar-SDK åˆ©ç”¨å¯†ç å­¦å’ŒåŒºå—é“¾çŠ¶æ€æ•°æ®ï¼Œå–ä»£ä¼ ç»Ÿçš„èº«ä»½éªŒè¯æ–¹æ³•ã€‚

è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥æ„å»ºä»»ä½•æƒ³è±¡çš„åº”ç”¨ã€‚ æ‚¨åªæ˜¯ç”¨ OpenAvatar-SDK è®¤è¯æ–¹å¼æ›¿æ¢ä¼ ç»Ÿçš„ç”¨æˆ·æ•°æ®åº“ã€‚

1. **ç®€å•èº«ä»½éªŒè¯ï¼š**  ä½¿ç”¨Web3é’±åŒ…ç™»å½•åº”ç”¨ç¨‹åºï¼ˆå…è®¸ä»»ä½•äººä½¿ç”¨é’±åŒ…ç™»å½•ï¼‰
2. **ä»…é™é‚€è¯·çš„åº”ç”¨ç¨‹åºï¼š** ä»…å…è®¸åœ°å€åˆ—è¡¨ä¸­çš„äººç™»å½•
3. **åŸºäº NFT çš„æˆæƒï¼š** æ ¹æ®é’±åŒ…æ‹¥æœ‰çš„ NFT ç™»å½•
4. **åŸºäº ERC20 çš„æˆæƒï¼š** åŸºäºé’±åŒ…æ‹¥æœ‰çš„ ERC20 ä»£å¸ç™»å½•
5. **ç©ºæŠ•ï¼š** å¯ä»¥é€šè¿‡æ›¾ä¸æŸä¸ªåˆçº¦äº¤äº’è¿‡çš„åœ°å€æ¥å®æ–½ç©ºæŠ•ã€‚
6. **Moreï¼š** æ ¹æ®ä»»ä½•åŒºå—é“¾æŸ¥è¯¢å®ç°æˆæƒã€‚


## ç¤¾ç¾¤æ”¯æŒ

æé—®æˆ–åé¦ˆï¼š:

1. Twitter: https://twitter.com/@yielddao
2. GitHub: https://github.com/openavatar

---


# å¿«é€Ÿå…¥é—¨

## 1. Server
æœåŠ¡ç«¯æœ‰ä¸¤ä¸ªæ­¥éª¤è¦åšï¼š

1. **è®¾ç½®åç«¯ï¼š** `privateparty` æ¨¡å—è®©æ‚¨è½»æ¾è®¾ç½®å—åŒºå—é“¾é’±åŒ…ç­¾åä¿æŠ¤çš„ [express.js]æœåŠ¡å™¨(https://expressjs.com/) ã€‚
2. **è¿æ¥åç«¯ï¼š** è®¾ç½®åç«¯åï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `partyconnect` åº“ä»æµè§ˆå™¨è¿›è¡Œè¿æ¥ã€‚

é¦–å…ˆå®‰è£…ä¾èµ–

```
npm install privateparty
```

æ¥ç€åˆ›å»ºä¸€ä¸ªåä¸º `index.js` çš„æ–‡ä»¶å¹¶ç¼–å†™åˆå§‹åŒ–é€»è¾‘ï¼š

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty()

// create a "user" group
party.add("user")

// authenticate using the "user" group.
party.app.get("/", party.auth("user"), (req, res) => {

  // the 'req.session' will be an empty object before the user authenticates
  console.log("session", req.session)

  // serve the index.html file to the public
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

## 2. Client

ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä¸æœåŠ¡å™¨ç«¯é€šä¿¡çš„æ–‡ä»¶ `index.html`ï¼š

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <button></button>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  // Get the "user" session
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  try {
    // Get the "user" session
    let session = await party.session("user")
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    // display error if something went wrong
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```

## 3. å¯åŠ¨ App

è¿è¡Œå‘½ä»¤:

```
node index
```

æ‰“å¼€æµè§ˆå™¨é“¾æ¥ http://localhost:3000 

å°±ä¼šçœ‹åˆ°ä¸‹é¢çš„ç»“æœï¼Œï¼š

![desktoplogin.gif](desktoplogin.gif)

## 4. æ”¯æŒæ‰‹æœºç§»åŠ¨é’±åŒ…

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åˆšåˆšä½¿ç”¨äº†æ¡Œé¢æµè§ˆå™¨ä¸Šå®‰è£…çš„é»˜è®¤é’±åŒ…ï¼ˆMetamaskï¼‰ã€‚ ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•æ”¯æŒç§»åŠ¨é’±åŒ…ã€‚

ä¸ºäº†æ”¯æŒç§»åŠ¨é’±åŒ…ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ [Walletconnect](https://walletconnect.com/)ã€‚ æ‚¨æ— éœ€å­¦ä¹ å¦‚ä½•ä½¿ç”¨ Walletconnectã€‚ åœ¨åˆ›å»º `Privateparty` å®ä¾‹æ—¶ï¼Œæ‚¨åªéœ€è¦ä¼ é€’ä¸€ä¸ªåä¸º `walletconnect` çš„å±æ€§ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```javascript
const party = new Privateparty({
  walletconnect: <Your Infura Key>
})
```

é¦–å…ˆæ³¨å†Œ [Infura](https://infura.io) ï¼Œåˆ›å»ºä¸€ä¸ªé¡¹ç›®å¹¶è·å–é¡¹ç›® IDã€‚

ç„¶åè®©æˆ‘ä»¬å›åˆ°ä¸Šé¢çš„å‰ç«¯ä¾‹å­ï¼Œåœ¨åˆå§‹åŒ– `Privateparty` å®ä¾‹æ—¶åªä¼ é€’ `walletconnect` å±æ€§ï¼š

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <button></button>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty({
  walletconnect: <USE YOUR OWN INFURA KEY>
})
const render = async () => {
  // Get the "user" session
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  try {
    // Get the "user" session
    let session = await party.session("user")
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    // display error if something went wrong
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```
æ³¨æ„ Walletconnect æ— æ³•åœ¨ localhost ä¸Šè¿è¡Œï¼Œå› æ­¤æ‚¨éœ€è¦è·å– HTTPS URL è¿›è¡Œæµ‹è¯•ã€‚ æ‚¨å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼åšåˆ°è¿™ä¸€ç‚¹ï¼š

1. å°†ç«™ç‚¹å…¬å¼€éƒ¨ç½²åˆ° HTTPS åŸŸï¼ˆæ‰€æœ‰ Web æ‰˜ç®¡æœåŠ¡æä¾›å•†é»˜è®¤æ”¯æŒæ­¤åŠŸèƒ½ï¼‰
  
2. ä½¿ç”¨ [ngrok](https://ngrok.com/) æˆ– [localtunnel](https://theboroer.github.io/localtunnel-www/) ç­‰è¿›è¡Œæœ¬åœ°æµ‹è¯•

è®©æˆ‘ä»¬å°è¯•ç¬¬äºŒç§æ–¹æ³•å¹¶ä½¿ç”¨ localtunnel åœ¨æœ¬åœ°è¿›è¡Œæµ‹è¯•ã€‚ éœ€è¦éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š

1.å¯åŠ¨privatepartyæœåŠ¡å™¨ï¼š`node index`

2.å¯åŠ¨ä¸€ä¸ªæŒ‡å‘privatepartyæœåŠ¡å™¨çš„localtunnelï¼š`npx lt --port 3000`

è¿™å°†ä¸ºæ‚¨æä¾›ä¸€ä¸ªå¯ä»¥æµ‹è¯•çš„å…¬å…± HTTPS ç½‘å€ã€‚ å°†å…¶å¤åˆ¶å¹¶ç²˜è´´åˆ°æµè§ˆå™¨ä¸­ã€‚ æ‚¨å°†çœ‹åˆ°ç±»ä¼¼äºä»¥ä¸‹åŠ¨ç”»çš„å†…å®¹ï¼ˆè¿™é‡Œæ¼”ç¤ºäº†ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„ç§»åŠ¨é’±åŒ… Metamask mobile å’Œ Rainbow é’±åŒ…ç™»å½•ï¼‰ï¼š

![mobilelogin.gif](mobilelogin.gif)

## 5. æ›´ç®€å•çš„èº«ä»½éªŒè¯

ä¸Šé¢ç¤ºä¾‹æ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨ JavaScript ä»¥ç¼–ç¨‹æ–¹å¼ç™»å½•æˆ–æ³¨é”€ã€‚

è¿˜æœ‰ä¸€ç§æ›´ç®€å•çš„æ–¹æ³•æ¥å®ç°ç™»å½•ï¼šåªéœ€åŒ…å«ä¸€ä¸ªé“¾æ¥ï¼ˆğŸ‘‡ğŸ»ä¸‹é¢ç¤ºæ„ï¼‰å°±å¯ä»¥å·¥ä½œï¼š

```
<a href="/privateparty/gate/user">Login</a>
```

å®ƒå°†ç”¨æˆ·å‘é€åˆ°å†…ç½®çš„ **"gate"** é¡µé¢ï¼Œè¯¥é¡µé¢ä¼šè‡ªåŠ¨å¤„ç†ç™»å½•å’Œæ³¨é”€ï¼Œå¹¶åœ¨å¤„ç†å®Œç™»å½•/æ³¨é”€åå°†ç”¨æˆ·è¿”å›ã€‚

è¦äº†è§£å¦‚ä½•æ‰§è¡Œæ­¤æ“ä½œï¼Œè¯·æŸ¥çœ‹â€œ[One-liner login/logout](#one-liner-loginlogout)â€éƒ¨åˆ†ã€‚

![gate.gif](gate.gif)

---

# ç¤ºä¾‹

## ä»…é‚€è¯·åº”ç”¨

ä»…å…è®¸æŒ‡å®šåœ°å€ç™»å½•ã€‚

### æœåŠ¡å™¨

å…ˆå®‰è£…ä¾èµ–

```
npm install privateparty
```

æ¥ç€åˆ›å»ºä¸€ä¸ªåä¸º `index.js` çš„æ–‡ä»¶å¹¶ç¼–å†™åˆå§‹åŒ–é€»è¾‘ï¼š

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty()
const MEMBERS = [
  "0xfb7b2717f7a2a30b42e21cef03dd0fc76ef761e9",
  "0x502b2fe7cc3488fcff2e16158615af87b4ab5c41"
]
party.add("user", {
  authorize: async (req, account) => {
    if (MEMBERS.includes(account)) {
      // if the account is part of the MEMBERS array, the account is authorized.
      // when authorized, the session will look like:
      //
      //  {
      //    account: <account>,
      //    auth: {
      //      member: true
      //    }
      //  }
      return { member: true }
    } else {
      throw new Error("not on the list!") 
    }
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

### å®¢æˆ·ç«¯

ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä¸æœåŠ¡å™¨é€šä¿¡çš„æ–‡ä»¶ï¼š`index.html`

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <button></button>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  try {
    let session = await party.session("user")
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```


## ERC20 é—¨æ§åº”ç”¨

æœ‰æ—¶ï¼Œæ‚¨å¯èƒ½å¸Œæœ›ç”¨æˆ·ä½¿ç”¨é’±åŒ…ç™»å½•ï¼Œå¹¶å­˜å‚¨æŒ‡å®š ERC20 ä»£å¸ä½™é¢ã€‚

è¿™å¯¹äºæ­å»ºç©ºæŠ•ç½‘ç«™ï¼Œæˆ–è®¸å¤šå…¶ä»–ç›®çš„çš„åº”ç”¨æ—¶ï¼Œå¯èƒ½å¾ˆæœ‰ç”¨ã€‚

### å®¢æˆ·

è®©æˆ‘ä»¬é¦–å…ˆæ­å»ºå‰ç«¯ã€‚ å…ˆåˆ›å»ºä¸€ä¸ªä¸æœåŠ¡å™¨é€šä¿¡çš„æ–‡ä»¶ï¼š `index.html` 

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <button></button>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  try {
    let session = await party.session("user")
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```


### Server

å¯¹äºè¿™ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å°†ï¼š

1. å…è®¸ä»»ä½•äººç™»å½•ã€‚
2. åœ¨åŒºå—é“¾ä¸­æŸ¥è¯¢ä»–ä»¬çš„ UNISWAP ä»£å¸ ($UNI) ä½™é¢ï¼Œå¹¶é€šè¿‡ cookie å°†å…¶ä¿å­˜ç”¨äºåç»§è®¿é—®ã€‚

ç”±äºæˆ‘ä»¬å°†æŸ¥è¯¢åŒºå—é“¾ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä½¿ç”¨ JSON-RPC ç«¯ç‚¹ã€‚


#### 1. å¤æ‚çš„æ–¹å¼

é¦–å…ˆå®‰è£…ä¾èµ–

```
npm install privateparty @alch/alchemy-web3
```

ç°åœ¨åˆ›å»ºä¸€ä¸ªåä¸º `index.js` çš„æ–‡ä»¶å¹¶ç¼–å†™åˆå§‹åŒ–é€»è¾‘ï¼š

```javascript
///////////////////////////////////////////////////////////////////////////////////////////
//
//  When a user logs in, take a snapshot of an ERC20 token balance and store it in cookie
//
///////////////////////////////////////////////////////////////////////////////////////////
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
const web3 = createAlchemyWeb3(<YOUR JSON-RPC ENDPOINT URL>)
const party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    const UNI = "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    let contract = new web3.eth.Contract([{
      "constant": true,
      "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ],
      "name": "balanceOf",
      "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }], UNI)
    let balance = await contract.methods.balanceOf(account).call()

    // Returning the additional attribute 'balance' will automatically set the value on the cookie
    // under the "auth" attribute
    return {
      balance: balance
    }
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```


ç”±äº `authorize()` å‡½æ•°ä¸ä¼šæŠ›å‡ºä»»ä½•é”™è¯¯ï¼Œè€Œåªä¼šè¿”å›ä½™é¢å¯¹è±¡ï¼Œå› æ­¤æ­¤åº”ç”¨ç¨‹åºå°†å…è®¸ä»»ä½•äººç™»å½•ï¼Œä½†ä½¿ç”¨ä½™é¢ä¿¡æ¯æ¥è¯†åˆ«ç”¨æˆ·ï¼ˆä¾‹å¦‚ï¼ŒæŒæœ‰äººå°†æ‹¥æœ‰éé›¶ä½™é¢ï¼Œè€Œ éæŒæœ‰è€…çš„ä½™é¢ä¸º0ï¼‰

#### 2. ç®€å•çš„æ–¹å¼

ç”±äº ERC20 å’Œ ERC721 æ˜¯å¸¸ç”¨çš„æ ‡å‡†ï¼ŒPrivateparty æä¾›äº†ä¸€ä¸ªå†…ç½®çš„ ABIï¼Œæ‚¨å¯ä»¥åˆ†åˆ«åœ¨ `party.abi.erc20` å’Œ `party.abi.erc721` ä¸‹è®¿é—®ã€‚

ä¸Šé¢å®Œå…¨ç›¸åŒçš„ä»£ç å¯ä»¥é‡å†™å¦‚ä¸‹ï¼š

```javascript
///////////////////////////////////////////////////////////////////////////////////////////
//
//  å½“ç”¨æˆ·ç™»å½•æ—¶ï¼Œè·å–ERC20ä»£å¸ä½™é¢ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨ cookie ä¸­
//
///////////////////////////////////////////////////////////////////////////////////////////
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
const web3 = createAlchemyWeb3(<YOUR JSON-RPC ENDPOINT URL>)
const party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    const UNI = "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    let balance = await party.contract(web3, party.abi.erc20, UNI).balanceOf(account).call()
    return {
      balance: balance
    }
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```


## NFT æ§åˆ¶åº”ç”¨

ä½¿ç”¨ç›¸åŒçš„åŸç†ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°é€šè¿‡ NFT æˆæƒçš„ç™»å½•ã€‚ ä¾‹å¦‚ï¼Œé€šå¸¸æ‚¨å¯èƒ½å¸Œæœ›åªå…è®¸äººä»¬åœ¨æ‹¥æœ‰è‡³å°‘ 1 ä¸ªï¼ˆæˆ–æ›´å¤šï¼‰é›†åˆä¸­çš„ NFT æ—¶ç™»å½•ã€‚

æ‚¨å¯ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½æ¥å®ç°é€šè¿‡ NFT è®¤è¯ç¤¾åŒºå’Œç½‘ç«™ã€‚

### Server

```javascript
///////////////////////////////////////////////////////////////////////////////////////////
//
//  When a user logs in, take a snapshot of an ERC20 token balance and store it in cookie
//
///////////////////////////////////////////////////////////////////////////////////////////
const Privateparty = require('privateparty')
const party = new Privateparty()
party.add("mfer", {
  contracts: {
    sartoshi: {
      address: "0xf7d134224a66c6a4ddeb7dee714a280b99044805",
      rpc: "https://eth-mainnet.alchemyapi.io/v2/NgVL3BEuBntBU4cbzjh3FxBIDO8dZM4y",
      abi: party.abi.erc721
    }
  },
  authorize: async (req, account, contracts) => {
    let balance = await contracts.sartoshi.methods.balanceOf(account).call()
    if (balance > 0) return { balance: balance }
    else throw new Error("must own at least one 'end of sartoshi'")
  }
})
party.app.get("/", party.protect("mfer"), (req, res) => {
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

### Client

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<h1>Some exclusive content!</h1>
<div>This page is protected by Privateparty "mfers" role</div>
</body>
</html>
```

## ç”¨ NFT ç™»å½•

![loginwithnft.gif](loginwithnft.gif)

æœ‰æ—¶ä½ å¯èƒ½æƒ³ç›´æ¥â€œä½¿ç”¨ NFT ç™»å½•â€ï¼Œå¹¶ç›´æ¥åœ¨ cookie ä¸­è®¾ç½® NFT å›¾åƒçš„URLã€‚

è¿™æ ·ï¼Œä¸€æ—¦ç”¨æˆ·ç™»å½•åº”ç”¨ç¨‹åºï¼Œåº”ç”¨ç¨‹åºå°±å¯ä»¥åœ¨æ•´ä¸ªåº”ç”¨ç¨‹åºä¼šè¯ä¸­ä½¿ç”¨è¯¥NFTçš„ç›¸å…³æ•°æ®ï¼ˆä¾‹å¦‚ç¼–å·ã€å›¾åƒ...ï¼‰ã€‚

ä½†æ˜¯ï¼ŒPrivateparty æœåŠ¡å™¨å¦‚ä½•çŸ¥é“æ‚¨æƒ³ä½¿ç”¨å“ªä¸ªç¡®åˆ‡çš„ NFT ç™»å½•ï¼Ÿ

éœ€è¦å‘æœåŠ¡å™¨å‘é€é¢å¤–çš„æ•°æ®ï¼Œå¯ä»¥åœ¨è°ƒç”¨ `connect()` æ–¹æ³•æ—¶ç®€å•åœ°ä¼ é€’å…¶ä»–å±æ€§ï¼š

### Client

è®©æˆ‘ä»¬é¦–å…ˆåˆ›å»ºä¸€ä¸ªä¸æœåŠ¡å™¨é€šä¿¡çš„æ–‡ä»¶ï¼š `index.html` 

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
img { width: 50px; height: 50px; flex-shrink: 0; margin-right: 10px; border-radius: 50px; }
nav { display: flex; align-items: center; }
</style>
</head>
<body>
<nav>
  <img class='hidden'>
  <input type='text' placeholder='collection address' id='collection'>
  <input type='text' placeholder='tokenId' id='id'>
  <button></button>
</nav>
<pre class='session'></pre>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("user")
  console.log("session", session)
  // if logged in (session exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
  if (session && session.auth && session.auth.image) {
    document.querySelector("img").src = session.auth.image 
    document.querySelector("img").classList.remove("hidden")
  } else {
    document.querySelector("img").classList.add("hidden")
  }
}
document.querySelector("button").addEventListener("click", async (e) => {
  let session = await party.session("user")
  if (session) {
    await party.disconnect("user")      // if logged in, log out
  } else {
    // Pass additional payload
    // These will be accessible as req.body.payload
    let connection = await party.connect("user", {
      collection: document.querySelector("#collection").value,
      tokenId: document.querySelector("#id").value
    })
    console.log("connection", connection)
  }
  await render()
})
render()
</script>
</body>
</html>
```

è¯·æ³¨æ„ç¬¬ä¸€è¡Œ `await party.connect("user")` , å®ƒä¼ é€’äº†ä¸€ä¸ªå…·æœ‰ `collection` å’Œ `tokenId` å±æ€§çš„å¯¹è±¡ï¼š

```javascript
let connection = await party.connect("user", {
  collection: document.querySelector("#collection").value,
  tokenId: document.querySelector("#id").value
})
```

ä¾‹å¦‚ï¼Œè¾“å…¥å€¼å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼š

```json
{
  collection: "0x6866ed9a183f491024692971a8f78b048fb6b89b",
  tokenId: "55005454344647406361450320675654878134478584534017520891306338141495783002503"
}
```

è¯¥å¯¹è±¡å°†ä½œä¸º `req.body.payload` ä¼ é€’ç»™ OpenAvatar-SDK æœåŠ¡å™¨ `authorize()` ç¨‹åºï¼Œä¸‹é¢å¯¹æ­¤è¿›è¡Œè§£é‡Šï¼š

### Server

é¦–å…ˆå®‰è£…ä¾èµ–åº“:

```
npm install privateparty @alch/alchemy-web3
```

ç„¶åï¼Œåˆ›å»ºä¸€ä¸ªåä¸º `index.js` çš„æ–‡ä»¶å¹¶ç¼–å†™åˆå§‹åŒ–é€»è¾‘ï¼š

```javascript
///////////////////////////////////////////////////////////////////////////////////////////
//
//  When a user logs in, take a snapshot of an ERC20 token balance and store it in cookie
//
///////////////////////////////////////////////////////////////////////////////////////////
const fetch = require('cross-fetch')
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
const web3 = createAlchemyWeb3(<YOUR JSON-RPC ENDPOINT URL>)
const party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    //  req.body.payload := {
    //    collection: "0x6866ed9a183f491024692971a8f78b048fb6b89b",
    //    tokenId: "55005454344647406361450320675654878134478584534017520891306338141495783002503"
    //  }
    console.log("req.body", req.body)
    console.log("account", account)

    // Query the blockchain to get the ERC721 tokenURI
    let tokenURI = await party.contract(web3, party.abi.erc721, req.body.payload.collection).tokenURI(req.body.payload.tokenId).call()
    // Get the image URL and turn it into IPFS gateway URL.
    let image = await fetch("https://ipfs.io/ipfs/" + tokenURI.replace("ipfs://", "")).then(r => r.json()).then(r => r.image)
    return {
      tokenURI,
      image: "https://ipfs.io/ipfs/" + image.replace("ipfs://", "")
    }
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

ç°åœ¨è¿è¡Œå‘½ä»¤ `node index` å¹¶æ‰“å¼€æµè§ˆå™¨é“¾æ¥ http://localhost:3000

æ‚¨å°†çœ‹åˆ°ä¸€ä¸ªç™»å½•ç•Œé¢ï¼Œå¯ä»¥åœ¨å…¶ä¸­è¾“å…¥ NFT åˆçº¦åœ°å€å’Œ tokenIdã€‚

åªæœ‰å½“ä½ çš„é’±åŒ…æ‹¥æœ‰ NFT æ—¶ï¼Œæ‰èƒ½ç™»å½•ã€‚


## å¤šè§’è‰²

Sometimes you may want to support multiple roles for a single account.

For example, Alice may be a "user" in a web app, but she may also be the "admin" who can have an admin interface. Only those with an "admin" role can access the admin interface, while the rest of the users can only have the "user" role and access the user interface.

Let's try building a minimal app that does that. We will build:

1. Privateparty server
2. User interface
3. Admin inteface

æœ‰æ—¶ä½ å¯èƒ½å¸Œæœ›ä¸ºå•ä¸ªå¸æˆ·æ”¯æŒå¤šè§’è‰²ã€‚

ä¾‹å¦‚ï¼ŒAlice å¯èƒ½æ˜¯ Web3 åº”ç”¨ä¸­çš„â€œuserâ€è§’è‰²ï¼Œä½†å¥¹ä¹Ÿå¯ä»¥æ‹¥æœ‰ç®¡ç†ç•Œé¢çš„â€œadminâ€è§’è‰²ã€‚ åªæœ‰æ‹¥æœ‰â€œadminâ€ç®¡ç†å‘˜è§’è‰²çš„ç”¨æˆ·æ‰èƒ½è®¿é—®ç®¡ç†ç•Œé¢ï¼Œè€Œå…¶ä½™æ‹¥æœ‰â€œuserâ€è§’è‰²çš„ç”¨æˆ·åªèƒ½å¹¶è®¿é—®æ™®é€šç”¨æˆ·ç•Œé¢ã€‚

è®©æˆ‘ä»¬æ­å»ºä¸€ä¸ªæœ€å°åº”ç”¨ç¤ºä¾‹ã€‚ æˆ‘ä»¬å°†å»ºç«‹ï¼š

1. OpenAvatar-SDK æœåŠ¡å™¨
2. ç”¨æˆ·é¡µé¢
3. ç®¡ç†å‘˜é¡µé¢

### Server

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty()

// Add a "user" role => will automatically create the default the following endpoints:
//
//  session: "/privateparty/admin/session",
//  connect: "/privateparty/admin/connect",
//  disconnect: "/privateparty/admin/disconnect",
//
party.add("user")

// Add an "admin" role with custom endpoints:
party.add("admin", {
  session: "/privateparty/admin/session",
  connect: "/privateparty/admin/connect",
  disconnect: "/privateparty/admin/disconnect",
  authorize: (req, account) => {
    // Currently anyone can login as admin, but you can add a logic to only allow certain addresses to login
    return { admin: true }
  }
})

// "user" interface => will display the index.html file
party.app.get("/", party.auth("user"), (req, res) => {
  res.sendFile(process.cwd() + "/index.html")
})

// "admin" interface => will display the admin.html file
party.app.get("/admin", party.auth("admin"), (req, res) => {
  res.sendFile(process.cwd() + "/admin.html")
})
party.app.listen(3000)
```

### ç”¨æˆ·é¡µé¢

é€šè¿‡ http://localhost:3000 è®¿é—®ç”¨æˆ·ç•Œé¢ï¼ˆè·¯ç”±â€œ/â€ï¼‰ï¼Œä»»ä½•å¸æˆ·éƒ½å¯ä»¥ç™»å½•ã€‚

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <h1>User page</h1>
  <button></button>
  <pre class='session'></pre>
  <a href="/admin">go to admin dashboard</a>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  let session = await party.session("user")
  try {
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```

### ç®¡ç†å‘˜é¡µé¢

é€šè¿‡ http://localhost:3000/admin è®¿é—®ç®¡ç†ç•Œé¢ï¼ˆè·¯ç”±â€œ/adminâ€ï¼‰ã€‚ æ‚¨å¯ä»¥ç”¨â€œç®¡ç†å‘˜â€èº«ä»½ç™»å½•ã€‚ ä¸Šé¢çš„OpenAvatar-SDK æœåŠ¡å™¨ä»£ç å…è®¸ä»»ä½•äººä»¥ç®¡ç†å‘˜èº«ä»½ç™»å½•ï¼Œä½†æ‚¨å¯ä»¥æ›´æ–° `authorize()` éƒ¨åˆ†ä»…æˆæƒç™½åå•ï¼ˆåå•ä¸­çš„åœ°å€å¯ä»¥ç™»å½•ï¼‰ä»¥ç®¡ç†å‘˜èº«ä»½ç™»å½•ã€‚

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <h1>Admin page</h1>
  <button></button>
  <pre class='session'></pre>
  <a href="/">go to user dashboard</a>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("admin")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  let session = await party.session("admin")
  try {
    if (session) {
      await party.disconnect("admin")      // if logged in, log out
    } else {
      await party.connect("admin")         // if logged out, log in
    }
    await render()
  } catch (e) {
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```


## è·¨åŸŸç™»å½•

æœ‰æ—¶ä½ çš„å‰ç«¯ä»£ç ä¸åç«¯å¯èƒ½è¿è¡Œåœ¨ä¸åŒçš„åŸŸä¸Šã€‚

åœ¨æ­¤ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥åº”ç”¨å†…ç½®çš„CORSåŠŸèƒ½ï¼Œä»…å…è®¸æŒ‡å®šåŸŸä½¿ç”¨æœåŠ¡ç«¯è¿›è¡Œèº«ä»½éªŒè¯ã€‚

éœ€è¦å¦‚ä¸‹è®¾ç½®ï¼š

1. OpenAvatar-SDK æœåŠ¡ç«¯è¿è¡Œåœ¨ 3007 ç«¯å£
2. å‰ç«¯è¿è¡Œåœ¨ 8080 ç«¯å£

å‰ç«¯ç½‘ç«™ï¼ˆ 8080 ï¼‰å°†ä½¿ç”¨ OpenAvatar-SDK æœåŠ¡å™¨ http://localhost:3007 è¿›è¡Œèº«ä»½éªŒè¯

### æœåŠ¡ç«¯ï¼ˆServer)

å°†ä¸‹é¢ä»£ç å¦å­˜ä¸º `index.js`ï¼š

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty({
  cors: {
    credentials: true,
    origin: ["http://localhost:8080"] // Allow port 8080 to access the server cross origin
  }
})
party.add("user")
party.app.listen(3000)
```

### å®¢æˆ·ç«¯ï¼ˆClientï¼‰

å°†ä¸‹é¢ä»£ç å¦å­˜ä¸º `index.html`ï¼š

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <button></button>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty({
  host: "http://localhost:3000"
})
const render = async () => {
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  let session = await party.session("user")
  try {
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```

å”¯ä¸€ä¸åŒçš„éƒ¨åˆ†æ˜¯åˆå§‹åŒ–æ­¥éª¤ï¼š

```javascript
const party = new Privateparty({
  host: "http://localhost:3000"
})
```

é»˜è®¤æƒ…å†µä¸‹ï¼Œ ä½¿ç”¨å®¢æˆ·ç«¯ï¼ˆpartyconnect.jsï¼‰å‘åŒä¸€ä¸ªåŸŸå‘å‡ºè¯·æ±‚ã€‚ ä½†æ˜¯æ‚¨å¯ä»¥åœ¨åˆå§‹åŒ– Privateparty å®¢æˆ·ç«¯æ—¶é€šè¿‡è®¾ç½® `host` å±æ€§æ¥è‡ªå®šä¹‰ç«¯ç‚¹ã€‚

### è¿è¡Œ

é¦–å…ˆå¯åŠ¨OpenAvatar-SDK æœåŠ¡ç«¯ï¼š

```
node index
```

ç„¶åä½¿ç”¨ä¸‹é¢å‘½ä»¤åœ¨ 8080 ç«¯å£å¯åŠ¨ `index.html` æœåŠ¡ï¼š

```
npx http-server
```

Now open the browser at http://localhost:8080 and it should work as intended.


## è·¨å¹³å°ç™»å½•

OpenAvatar ç”± [JWT](https://en.wikipedia.org/wiki/JSON_Web_Token) æä¾›å®ç°æ”¯æŒã€‚

è¿™æ„å‘³ç€å¯ä»¥åœ¨**æµè§ˆå™¨ä¹‹å†…å’Œå¤–éƒ¨**ä½¿ç”¨ç›¸åŒçš„ç”Ÿæˆä»¤ç‰Œï¼Œ â€œæµè§ˆå™¨ä¹‹å¤–â€å¯ä»¥æ˜¯ä»»ä½•åœ°æ–¹ï¼ŒåŒ…æ‹¬ï¼š

- ç§»åŠ¨åº”ç”¨
- æœåŠ¡å™¨
- æ— æœåŠ¡å™¨åŠŸèƒ½ï¼ˆAWS lambdaã€vercelã€netlify ç­‰ï¼‰
- ç‰©è”ç½‘è®¾å¤‡
- ç­‰ç­‰..

è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ node.js åº”ç”¨ç¨‹åºè¿›è¡Œèº«ä»½éªŒè¯å’Œæˆæƒã€‚

### æœåŠ¡ç«¯ï¼ˆServerï¼‰

ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå…è®¸ä»»ä½•äººç™»å½•çš„OpenAvatar-SDKæœåŠ¡å™¨ï¼ˆå› æ­¤æ²¡æœ‰ `authorize()` å‡½æ•°ï¼‰ï¼š
```javascript
///////////////////////////////////////////////////////////////////////////////////////////
//
//  When a user logs in, take a snapshot of an ERC20 token balance and store it in cookie
//
///////////////////////////////////////////////////////////////////////////////////////////
const Privateparty = require('privateparty')
const party = new Privateparty()
party.add("user")
party.app.get("/api", party.protect("user", { json: { error: "not logged in" } }), (req, res) => {
  res.json({ status: "Logged in!" })
})
party.app.listen(3000)
```


### å®¢æˆ·ç«¯ ï¼ˆClientï¼‰

ä¸ºæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªåä¸º `partypass` çš„ node.js å®¢æˆ·ç«¯,  å’Œ `cross-fetch`ï¼ˆå‘å‡º fetch è¯·æ±‚ï¼‰ã€‚

```
npm install partypass
```

ç„¶ååˆ›å»ºä¸€ä¸ªåä¸º `client.js` çš„æ–‡ä»¶ï¼š

```javascript
const Partypass = require('partypass')
const fetch = require('cross-fetch')
const run = async () => {
  const pass = new Partypass({
    host: "http://localhost:3000",
    key: "cd76c32ffeae94b725b40b1f58ffc793d5b0e96596f8d067f29d385894f16424" // replace with your private key
  });
  const session = await pass.create("user"); // The session object will contain { jwt, account, ... }

  // Now let's make a request with the jwt
  let response = await fetch("http://localhost:3000/api", {
    headers: {
      authorization: `token ${session.jwt}`
    }
  }).then((r) => {
    return r.json()
  })
  console.log(response)
}
run()   // run it!
```

è¿è¡Œå‘½ä»¤ï¼š `node client` 

1. `client.js` å‘ OpenAvatar æœåŠ¡å™¨çš„3000ç«¯å£ å‘å‡ºè¯·æ±‚ä»¥è·å– Session ä¼šè¯
2. ç„¶åå®ƒå°†ä½¿ç”¨æˆæƒå¤´ä¸­çš„`session.jwt`å‘`/api`ç«¯ç‚¹å‘å‡ºç»è¿‡èº«ä»½éªŒè¯çš„è¯·æ±‚ï¼Œå¹¶æˆåŠŸã€‚

å°†æ‰“å°ä¸‹é¢ä¿¡æ¯ï¼š

```
{ status: 'Logged in!' }
```

æ¥ä¸‹æ¥ï¼Œä¸ºäº†ç¡®ä¿åœ¨æ²¡æœ‰æºå¸¦ä»¤ç‰Œæ—¶è¯·æ±‚ä¼šå¤±è´¥ï¼Œæˆ‘ä»¬è¯•è¯•å‘å‡ºç›¸åŒçš„è¯·æ±‚ï¼Œä½†æ²¡æœ‰å¸¦ä¸Šæˆæƒå¤´ï¼š

```javascript
const Partypass = require('partypass')
const fetch = require('cross-fetch')
const run = async () => {
  let response = await fetch("http://localhost:3000/api").then((r) => {
    return r.json()
  })
  console.log(response)
}
run()   // run it!
```

å°†æ‰“å°ä¸‹é¢ä¿¡æ¯ï¼š

```
{ error: 'not logged in' }
```

## ä¸€è¡Œä»£ç å®ç° ç™»å½•/æ³¨é”€

æˆ‘ä»¬å·²ç»ç ”ç©¶äº†ä½¿ç”¨ JavaScript è¿›è¡Œèº«ä»½éªŒè¯çš„æ–¹æ³•ã€‚ ä½†æ˜¯è¿˜æœ‰ä¸€ç§æ›´ç®€å•çš„å…¥é—¨æ–¹æ³•ã€‚ æ‚¨éœ€è¦åšçš„å°±æ˜¯å°†ç”¨æˆ·ç™»å½•ä¿¡æ¯å‘é€åˆ° â€œgateâ€ é¡µé¢ã€‚

### æœåŠ¡ç«¯ ï¼ˆServerï¼‰

æˆ‘ä»¬é¦–å…ˆç¼–å†™ä¸€ä¸ªåä¸º `app.js` çš„æ–‡ä»¶æ¥è®¾ç½®ä¸€ä¸ªç®€å•çš„ OpenAvatar-SDK æœåŠ¡ç«¯ã€‚


```javascript
const party = new Privateparty()
party.add("user")
party.app.get("/", (req, res) => {
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

å½“ç”¨æˆ·è¿›å…¥`/`è·¯ç”±æ—¶ï¼Œæ— è®ºæ˜¯å¦ç™»å½•ï¼Œéƒ½ä¼šæ˜¾ç¤º`index.html`é¡µé¢ã€‚ æˆ‘ä»¬çœ‹ä¸€ä¸‹ `index.html` ï¼š

### å®¢æˆ·

ä»¥ä¸‹ä»£ç ä¸ä½¿ç”¨ä»»ä½• JS ä»£ç è¿›è¡Œèº«ä»½éªŒè¯ã€‚ ç›¸åï¼Œåªéœ€æ·»åŠ ä¸€è¡Œä»£ç `<a id='account' href='/privateparty/gate/user?callback=/'></a>`ï¼Œç”¨æˆ·å°±å¯ä»¥ç‚¹å‡»æ‰“å¼€â€œgateâ€é¡µé¢æ¥ç™»å½•æˆ–æ³¨é”€ï¼Œç„¶åè¿”å›ï¼ˆæœ‰ç‚¹åƒä¸ºâ€œfacebook connectâ€æ‰“å¼€ä¸€ä¸ª facebook ç™»å½•é¡µé¢å¹¶åœ¨ç™»å½•åé‡å®šå‘å›æ¥ï¼‰ï¼š


```html
<html>
<head>
<script src="https://unpkg.com/partyconnect@0.0.42/dist/partyconnect.js"></script>
</head>
<body>
<nav>
  <a id='account' href="/privateparty/gate/user?callback=/"></a>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("user")

  // if logged in, display the account. Otherwise display "login"
  document.querySelector("a").innerHTML = (session ? session.account : "login")

  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
render()
</script>
</body>
</html>
```

Run the server with `node app.js` and go to http://localhost:3000 - you will see:
è¿è¡Œ `node app.js` å¯åŠ¨æœåŠ¡å™¨å¹¶è®¿é—® http://localhost:3000 - ä¼šçœ‹åˆ°ï¼š

![gate.gif](gate.gif)

> æ³¨æ„æµè§ˆå™¨ URL çš„å˜åŒ–ã€‚
>
> - å½“ç”¨æˆ·ç‚¹å‡»â€œç™»å½•â€æ—¶ï¼Œå®ƒä¼šè½¬åˆ° /privateparty/gate/user?callback=/
> - ç™»å½•åè‡ªåŠ¨é‡å®šå‘å›â€œ/â€ï¼Œå› ä¸ºå›è°ƒ
> - æ³¨é”€è¿‡ç¨‹ç›¸åŒã€‚æ³¨é”€åï¼Œå®ƒä¼šè‡ªåŠ¨é‡å®šå‘å›â€œ/â€

è®©æˆ‘ä»¬é€šè¿‡ HTML æ¥çœ‹çœ‹å‘ç”Ÿäº†ä»€ä¹ˆã€‚

1. é¦–å…ˆï¼Œ`render()` æ–¹æ³•æ£€æŸ¥ `user` ä¼šè¯ï¼Œå¦‚æœå·²ç»ç™»å½•åˆ™æ˜¾ç¤ºå¸æˆ·ä¿¡æ¯ï¼Œå¦åˆ™å°± â€œç™»å½•â€ã€‚è¿™éƒ¨åˆ†æˆ‘ä»¬å¾ˆç†Ÿæ‚‰ã€‚
2. æ¥ä¸‹æ¥ï¼Œæ³¨æ„ `<a>` æ ‡ç­¾ã€‚å®ƒæœ‰ä¸€ä¸ª `/privateparty/gate/user?callback=/` çš„ `href` å±æ€§ã€‚è®©æˆ‘ä»¬åˆ†è§£ä¸€ä¸‹ã€‚
    - `/privateparty/gate/user` æ˜¯å†…ç½®â€œgateâ€é¡µé¢çš„é»˜è®¤è·¯ç”±ï¼Œå…è®¸ç”¨æˆ·ç™»å½•ï¼ˆå¦‚æœå·²æ³¨é”€ï¼‰æˆ–æ³¨é”€ï¼ˆå¦‚æœå·²ç™»å½•ï¼‰ã€‚
      - è¯¥è·¯ç”±æ˜¯æ ¹æ®è§’è‰²åç§°è‡ªåŠ¨ç”Ÿæˆçš„ã€‚ä¾‹å¦‚ï¼Œè¦å°†ç”¨æˆ·å‘é€åˆ°â€œadminâ€è§’è‰²ç™»å½•é¡µé¢ï¼Œé“¾æ¥å°†æ˜¯â€œ/privateparty/gate/adminâ€ã€‚
    - `?callback=/` éƒ¨åˆ†å‘Šè¯‰ç½‘å…³é¡µé¢åœ¨ç”¨æˆ·ç™»å½•ï¼ˆæˆ–æ³¨é”€ï¼‰åå°†å…¶é‡å®šå‘åˆ°å“ªä¸ª URLã€‚
      - åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›ç™»å½•é¡µé¢è‡ªåŠ¨å°†ç”¨æˆ·é€å›`/`è·¯ç”±ï¼Œæ‰€ä»¥`callback`æ˜¯`/`ã€‚

### ç§»åŠ¨ç«¯æ”¯æŒ

è¦è‡ªåŠ¨æ”¯æŒå†…ç½®gateé¡µé¢çš„ç§»åŠ¨é’±åŒ…ï¼Œæ‚¨éœ€è¦ä½¿ç”¨å¸¦æœ‰ `walletconnect` å±æ€§ï¼ˆInfura IDï¼‰çš„è‡ªå®šä¹‰ `gate` é…ç½®ï¼Œæ¥åˆå§‹åŒ– Privateparty ï¼š

```javascript
const party = new Privateparty({
  gate: {
    walletconnect: "667750972a89441ea5d276ed16d7eef0"
  }
})
party.add("user")
party.app.get("/", (req, res) => {
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```


## æ›´å¤šç¤ºä¾‹

æŸ¥çœ‹ GitHub ä¸Šçš„ [demo æ–‡ä»¶å¤¹](https://github.com/openavatar/openavatar-server/tree/main/demo) ä»¥è·å–æ›´å¤šç¤ºä¾‹ã€‚

## React ç»„ä»¶

å¦‚æœä½¿ç”¨ react? å¯ä»¥è¯•è¯• react ç»„ä»¶: [Partybutton](https://partybutton.papercorp.org/)

![partybutton.png](partybutton.png)

---

# å®‰è£…

å¯ä»¥ä½¿ç”¨2ä¸ªåº“ï¼ˆæœåŠ¡å™¨ç«¯å’Œå®¢æˆ·ç«¯ï¼‰æ¥å®ç° OpenAvatar Web3 åº”ç”¨ç¨‹åºï¼š

1. `privateparty`ï¼šOpenAvatar æœåŠ¡å™¨ç«¯æ¨¡å— 
2. `partyconnect`ï¼šOpenAvatar çš„æµè§ˆå™¨å®¢æˆ·ç«¯=>ç™»å½•åè‡ªåŠ¨ä½¿ç”¨æµè§ˆå™¨é’±åŒ…å¹¶è®¾ç½®cookiesã€‚
3. `partypass`ï¼šOpenAvatar çš„ node.js å®¢æˆ·ç«¯ => æ— çŠ¶æ€å®¢æˆ·ç«¯ï¼Œç”¨äºå‘ OpenAvatar æœåŠ¡å™¨å‘å‡ºè¯·æ±‚å¹¶åœ¨ JWT ä¸­å–å›æ–°ä¼šè¯ã€‚
4. 

## æœåŠ¡ç«¯ï¼ˆServerï¼‰

å®‰è£…æœåŠ¡ç«¯:

```
npm install privateparty
```

ç„¶åï¼Œåœ¨ä½ çš„åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨è¯¥æ¨¡å—ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty()
```

## æµè§ˆå™¨å®¢æˆ·ç«¯

### ä»CDNåŠ è½½

å¦‚ä¸‹æ‰€ç¤ºï¼Œåœ¨å‰ç«¯APPé‡Œï¼ˆä»CDNï¼‰åŠ è½½

```html
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
```

### å¼•å…¥ï¼ˆImportï¼‰

```
npm install partyconnect
```

ç„¶åè¿›è¡Œåˆå§‹åŒ–ï¼š

```javascript
// CJS
const Privateparty = require('partyconnect')
const party = new Privateparty(config)
```

æˆ–è€…

```javascript
// ESM
import Privateparty from 'partyconnect'
const party = new Privateparty(config)
```

> å¦‚æœä»£ç è¿è¡Œæ­£å¸¸ï¼Œä½†åœ¨å°è¯•ä½¿ç”¨ webpack æ‰“åŒ…ç”Ÿäº§æ—¶é‡åˆ°é—®é¢˜ï¼Œå¯èƒ½æ˜¯å› ä¸º webpack 5 å·²å¼€å§‹å»é™¤ node.js core moduleï¼ˆå¯¹äºä»»ä½•ä½¿ç”¨ node.js æ ¸å¿ƒæ¨¡å—çš„åº“ï¼‰ã€‚ è¯·å‚é˜…æœ¬æ–‡ä»¥äº†è§£å¦‚ä½•è§£å†³æ­¤é—®é¢˜ï¼šhttps://www.alchemy.com/blog/how-to-polyfill-node-core-modules-in-webpack-5

## Node.js å®¢æˆ·ç«¯

### å¯¼å…¥ï¼ˆImportï¼‰

```
npm install partypass
```

ç„¶ååˆå§‹åŒ–:

```javascript
// CJS
const Partypass = require('partypass')
const pass = new Partypass(config)
```

æˆ–è€…

```javascript
// ESM
import Partypass from 'partypass'
const pass = new Partypass(config)
```

### ä»CDNåŠ è½½

è™½ç„¶partypass æ˜¯ä¸€ä¸ªnode.jså®¢æˆ·ç«¯ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹æ‚¨å¯ä»¥åœ¨Webç¯å¢ƒä¸­ä½¿ç”¨å®ƒã€‚

ä¾‹å¦‚ï¼ŒæœåŠ¡å™¨å¯ä»¥ä½¿ç”¨`pass.build()`åˆ›å»ºä¸€ä¸ªpassåˆ›å»ºè¯·æ±‚ï¼Œå¹¶å°†å…¶å‘é€åˆ°ç”¨æˆ·çš„æµè§ˆå™¨ï¼Œç”¨æˆ·ä½¿ç”¨`pass.request()`å‘å‡ºè¯·æ±‚ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨è¿˜å¯ä»¥ä½¿ç”¨ CDN JSï¼š

åŒ…æ‹¬åœ¨webå‰ç«¯åº”ç”¨ä¸­ï¼š

```html
<script src="https://unpkg.com/partypass/dist/partypass.js"></script>
```

---

# API

## æœåŠ¡ç«¯ï¼ˆServerï¼‰

å¯¹äºåç«¯éœ€è¦ä½¿ç”¨åŒ… `privateparty`ã€‚ åªéœ€å®ä¾‹åŒ–ä¸€ä¸ªæ–° `Privateparty` å®ä¾‹ï¼Œå®ƒå°±ä¼šä¸ºæ‚¨æ­å»ºä¸€ä¸ªWeb3é’±åŒ…ä¿æŠ¤çš„ Web åº”ç”¨åç«¯ã€‚

### æ„é€ å‡½æ•°

#### è¯­æ³•

```javascript
const party = new Privateparty(config)
```

#### å‚æ•°

- `config`: openavatar æœåŠ¡ç«¯é…ç½® 
  - `secret`: **(å¯é€‰)** ç”¨äºç­¾ç½² cookie çš„å­—ç¬¦ä¸²
    - å‚è€ƒ https://github.com/expressjs/cookie-parser#cookieparsersecret-options
    - å¦‚æœæœªæŒ‡å®šï¼Œå®ƒå°†åœ¨æ¯æ¬¡æœåŠ¡å™¨é‡æ–°å¯åŠ¨æ—¶ä½¿ç”¨uuidè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªsecretå¯†é’¥ [uuid](https://github.com/uuidjs/uuid).
  - `cors`: **(å¯é€‰)** å¦‚æœæ‚¨æƒ³æ”¯æŒ CORSï¼ˆè·¨æºè¯·æ±‚ï¼‰ï¼Œè¯·æ·»åŠ æ­¤å±æ€§ã€‚
    - å‚è€ƒ https://github.com/expressjs/cors#configuration-options
  - `app`: **(å¯é€‰)** æ³¨å…¥ç°æœ‰ express.js åº”ç”¨å®ä¾‹
  - `express`: **(å¯é€‰)** æ³¨å…¥ä¸€ä¸ªç°æœ‰çš„ express æ¨¡å—
  - `gate`: **(å¯é€‰)** å†…ç½®gateé¡µé¢é…ç½®
    - `walletconnect`: Walletconnect Infura IDï¼Œç”¨äºæ”¯æŒç§»åŠ¨é’±åŒ…ã€‚
    - `fresh`: ä½¿ç”¨é»˜è®¤ç™»å½•é¡µé¢æ—¶ï¼Œç™»å½•æ˜¯å¦è¦æ±‚ç”¨æˆ·ï¼ˆé‡æ–°ï¼‰è¿æ¥é’±åŒ…åˆ—è¡¨ä¸­çš„é’±åŒ…ï¼Œæˆ–è€…å¦‚æœä»ç„¶è¿æ¥åˆ™ä½¿ç”¨ä¹‹å‰è¿æ¥çš„é’±åŒ…
       - å¦‚æœè®¾ç½® `true`ï¼Œç™»å½•æ€»æ˜¯æ˜¾ç¤ºåˆ—è¡¨ä¸­çš„æ‰€æœ‰é’±åŒ…å¹¶è®©ç”¨æˆ·é€‰æ‹©ä¸€ä¸ª
       - å¦‚æœè®¾ç½® `false`ï¼Œè·³è¿‡é’±åŒ…é€‰æ‹©æ­¥éª¤ï¼Œä½¿ç”¨ä¹‹å‰é€‰æ‹©çš„é’±åŒ…ï¼ˆè¿™æ˜¯é»˜è®¤è®¾ç½®ï¼‰

#### è¿”å›å€¼

- `party`: ç»è¿‡åˆå§‹åŒ–çš„ privateparty å®ä¾‹ï¼ŒåŒ…å«ä»¥ä¸‹å±æ€§ï¼š
  - `app`: é€šè¿‡è°ƒç”¨ `const app = express()` åœ¨å†…éƒ¨åˆ›å»ºçš„â€œappâ€å®ä¾‹
  - `express`: express æ¨¡å—
  - `auth`: è®¤è¯æˆæƒåŠŸèƒ½
  - `protect`: è®¤è¯æˆæƒåŠŸèƒ½+é”™è¯¯å¤„ç†
  - `add`: æ·»åŠ æˆæƒç»„çš„åŠŸèƒ½

> the `auth` method only tells you if the authorization results in a legitimate session or not, whereas the `protect` method is used to do what `auth` does but also automatically redirect to a logged out page or display a logged out page.
> `auth` æ–¹æ³•ä»…å‘Šè¯‰ä½ æˆæƒæ˜¯å¦ç”Ÿæˆåˆæ³•ä¼šè¯ï¼Œè€Œ `protect` æ–¹æ³•ç”¨äºæ‰§è¡Œ `auth` æ‰€åšåŠŸèƒ½ï¼Œä½†ä¼šè‡ªåŠ¨é‡å®šå‘åˆ°å·²æ³¨é”€çš„é¡µé¢æˆ–æ˜¾ç¤ºå·²æ³¨é”€çš„é¡µé¢ .

#### ç¤ºä¾‹

##### 1. æœ€å°åŒ–æœåŠ¡ç«¯

```javascript
const party = new Privateparty()
```

##### 2. å…·æœ‰å›ºå®šç­¾åå¯†é’¥çš„æœåŠ¡å™¨

```javascript
const party = new Privateparty({
  secret: "top secret"
})
```

##### 3. è·¨åŸŸç™»å½•

In the following example, we have a privateparty server running at port 3001, and it allows requests from not just the port 3001 but also 3000, since we specified the origin http://localhost:3000

åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªè¿è¡Œåœ¨ 3001 ç«¯å£çš„ openavatar æœåŠ¡å™¨ï¼Œå®ƒä¸ä»…å…è®¸æ¥è‡ªç«¯å£ 3001 çš„è¯·æ±‚ï¼Œè¿˜å…è®¸æ¥è‡ª 3000 çš„è¯·æ±‚ï¼Œå› ä¸ºæˆ‘ä»¬æŒ‡å®šäº†æº http://localhost:3000

```javascript
const party = new Privateparty({
  cors: {
    credentials: true,
    origin: ["http://localhost:3000"]
  }
})
party.listen(3001)
```

##### 4. å…·æœ‰åŠ¨æ€æºè§£æçš„è·¨åŸŸç™»å½•

ä½¿ç”¨ CORS æ¨¡å— (https://github.com/expressjs/cors#configuring-cors-w-dynamic-origin) ä¸­çš„åŠ¨æ€æºé…ç½®é€‰é¡¹ï¼Œæ‚¨å¯ä»¥åŠ¨æ€è§£æè¯·æ±‚æºå¹¶æˆæƒï¼š

```javascript
const party = new Privateparty({
  cors: {
    credentials: true,
    origin: (origin, callback) => {
      // allow ALL localhost connections
      if (/localhost:[0-9]+/i.test(origin)) {
        callback(null, true)
      } else {
        callback(new Error())
      }
    }
  }
})
party.listen(3001)
```

##### 5. ä¸å·²æœ‰ express.js åº”ç”¨é›†æˆ

```javascript
const express = require('express')
const app = express()
const port = 3000

// Inject express app to Privateparty!
const party = new Privateparty({
  app: app,
})
// Define the authorization logic
party.add("user", {
  authorize: (req, account) => {
    // only allow 0xf7d134224a66c6a4ddeb7dee714a280b99044805 to log in
    if (account === "0xf7d134224a66c6a4ddeb7dee714a280b99044805") {
      return { authorized: true }
    } else {
      throw new Error("not allowed")
    }
  }
})
// Protect the app with the authorization role!
app.get('/', party.protect("user"), (req, res) => {
  res.send('Hello World!')
})
app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})
```

### add()

æ·»åŠ ä¸€ä¸ªç»„åˆ° OpenAvatar

#### è¯­æ³•

```javascript
await party.add(name, config)
```

#### å‚æ•°

- `name`: ç»„å (æ¯ä¸ªç»„å¿…é¡»å”¯ä¸€)
- `config`: æ¯ä¸ªç»„çš„é…ç½®é€‰é¡¹
  - `session`ï¼šï¼ˆå¯é€‰ï¼‰æŸ¥è¯¢æ­¤å¼•æ“å½“å‰ä¼šè¯çš„ GET è·¯å¾„ã€‚ ï¼ˆé»˜è®¤ï¼š`/privateparty/session/${name}`ï¼‰
  - `connect`ï¼šï¼ˆå¯é€‰ï¼‰ä¸ºæ­¤å¼•æ“åˆ›å»ºä¼šè¯çš„ POST è·¯å¾„ï¼ˆé»˜è®¤å€¼ï¼š`/privateparty/connect/${name}`ï¼‰
  - `disconnect`ï¼šï¼ˆå¯é€‰ï¼‰é”€æ¯æ­¤å¼•æ“ä¼šè¯çš„ POST è·¯å¾„ï¼ˆé»˜è®¤å€¼ï¼š`/privateparty/disconnect/${name}`ï¼‰
  - `gate`ï¼šï¼ˆå¯é€‰ï¼‰æ­¤å¼•æ“çš„ç½‘å…³é¡µé¢è·¯ç”±ï¼ˆâ€œç™»å½•/æ³¨é”€â€é¡µé¢ï¼‰ï¼ˆé»˜è®¤ï¼š`privateparty/gate/${name}`ï¼‰
  - `authorize`ï¼šä¸€ä¸ªæ¥å—ä¸¤ä¸ªæˆ–å¤šä¸ªå‚æ•°çš„å‡½æ•°`req`ï¼ˆä»expressä¼ é€’çš„ä¼ å…¥è¯·æ±‚å¯¹è±¡ï¼‰ï¼Œ`account`ï¼ˆç»è¿‡èº«ä»½éªŒè¯çš„é’±åŒ…åœ°å€ï¼‰å’Œå¯é€‰çš„`contracts`ï¼ˆä»…å½“æ‚¨æŒ‡å®šå¦ä¸€ä¸ªå±æ€§`contracts `ï¼Œè§£é‡Šå¦‚ä¸‹ï¼‰ã€‚
    - è¦ç¦æ­¢åŸºäºè¯·æ±‚çš„ä¼šè¯ï¼Œåªéœ€åœ¨å‡½æ•°ä¸­æŠ›å‡ºé”™è¯¯ã€‚
    - è¦æˆæƒä¼šè¯ï¼Œè¯·ä¸è¦æŠ›å‡ºå‡½æ•°ã€‚å¦å¤–ï¼Œè¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ä¼šè‡ªåŠ¨è®¾ç½®ä¸ºä¼šè¯çš„ `auth` å±æ€§
  - `expire`ï¼šï¼ˆå¯é€‰ï¼‰ä¼šè¯æŒç»­æ—¶é—´ï¼ˆä¼šè¯è¿‡æœŸçš„ç§’æ•°ï¼‰ã€‚é»˜è®¤å€¼ä¸ºâ€œ1000 * 60 * 60 * 24 * 30â€ï¼ˆ30 å¤©ï¼‰ã€‚
  - `tokens`ï¼šï¼ˆå¯é€‰ï¼‰å…è®¸è®¿é—®ä»¤ç‰Œçš„æ•°ç»„
  - `contracts`ï¼šï¼ˆå¯é€‰ï¼‰ç”¨äºå®šä¹‰ä¸€ä¸ªæˆ–å¤šä¸ªåˆçº¦çš„å£°æ˜æ€§å¯¹è±¡ï¼Œå®ƒå°†è¢«åˆå§‹åŒ–å¹¶æ³¨å…¥åˆ° `authoirze()` å¤„ç†ç¨‹åº

#### è¿”å›å€¼

none

#### ç¤ºä¾‹

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty()
party.add("user", {

  session: "/privateparty/session/user",            // custom path for the session route
  connect: "/privateparty/connect/user",            // custom path for the connect route 
  disconnect: "/privateparty/disconnect/user",      // custom path for the disconnect route
  gate: "/privateparty/gate/user",                  // custom path for the gate page route

  // Define as many contracts as you want, using <name>: <description object>
  contracts: {
    sartoshi: {
      address: "0xf7d134224a66c6a4ddeb7dee714a280b99044805",
      rpc: process.env.RPC,
      abi: party.abi.erc721
    }
  },

  authorize: async (req, account, contracts) => {

    // The "request" is the full HTTP request object (express.js)
    // The "account" is the account derived from the incoming signature
    // The "contracts" is an object made up of instantiated Web3.js contract objects, determined by the "contracts" attribute above

    let balance = await contracts.sartoshi.methods.balanceOf(account).call()
    console.log("balance", balance)
    if (balance > 0) {
      return { balance: balance }
    } else {
      throw new Error("must own at least one 'end of sartoshi'")
    }
  },

  expire: 1000 * 60 * 60 * 24,   // expire after 1 day

  // access tokens for API access
  tokens: [
    "01127c36-32fa-4c85-b6da-f720796fe679",
    "35161a5c-60f0-4809-8b49-1a662247f5b3"
  ]
  

})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

### auth()

æˆæƒä¸­é—´ä»¶ï¼Œå¯ä»¥æ·»åŠ åˆ°ä»»ä½•è·¯ç”±ä¸­ã€‚

è¦å°†æˆæƒé€»è¾‘æ·»åŠ åˆ°ä»»ä½•è·¯ç”±ï¼Œæ‚¨éœ€è¦ï¼š

1. é¦–å…ˆé€šè¿‡`add()`æ–¹æ³•å®šä¹‰ä¸€ä¸ªæˆæƒç»„åŠå…¶è¡Œä¸º
2. ç„¶åé€šè¿‡è°ƒç”¨ `party.auth(name)` æ¥ä½¿ç”¨è¯¥ç»„

#### è¯­æ³•

```javascript
party.app.get(route1, party.auth(name), (req, res) => {
  ...
})
party.app.post(route2, party.auth(name), (req, res) => {
  ...
})
```

#### å‚æ•°

- `name`: ç”¨äºè·¯ç”±å¤„ç†ç¨‹åºçš„æˆæƒç»„åç§°


#### ç¤ºä¾‹

##### 1. ç¼ºçœèº«ä»½éªŒè¯

ä»¥ä¸‹ç¤ºä¾‹ä»…æ ¹æ®é’±åŒ…ç­¾åå¯¹ç”¨æˆ·å¸æˆ·è¿›è¡Œèº«ä»½éªŒè¯ã€‚

```javascript
const party = new Privateparty()
party.add("user")
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
```


1. `party.add("user"` å°†åˆ›å»ºä¸€ä¸ªåä¸º "user" çš„ç»„ï¼Œå®ƒä¼šè‡ªåŠ¨åˆ›å»ºä»¥ä¸‹è·¯ç”±ï¼š
     - `POST /privateparty/connect`
     - `POST /privateparty/disconnect`
     - `GET /privateparty/session`
2. ç„¶å express åº”ç”¨å®ä¾‹ï¼ˆ`party.app`ï¼‰å¤„ç† `GET /` è¯·æ±‚ã€‚ ä½†åœ¨æ­¤ä¹‹å‰ï¼Œå®ƒä¼šé€šè¿‡ `party.auth("user")` ä¸­é—´ä»¶ã€‚
3. ç”±äº `party.add("user")` æ²¡æœ‰æŒ‡å®šä»»ä½•æˆæƒé€»è¾‘ï¼Œæ‰€ä»¥å…è®¸æ‰€æœ‰è¯·æ±‚ã€‚
4. å› æ­¤ï¼Œå½“ç”¨æˆ·ç¬¬ä¸€æ¬¡è®¿é—®`/`è·¯ç”±æ—¶ï¼Œ`req.session`å°†ä¸ºç©ºï¼Œä½†æ˜¯...
5. å‰ç«¯è®¤è¯åï¼Œ`req.session` å°†åŒ…å« `{ "user": { "account": <user address> } }`

##### 2. æˆæƒ

é»˜è®¤æƒ…å†µä¸‹ï¼ŒPrivateparty è®©æ‰€æœ‰äººéƒ½ç™»å½•ã€‚ä½†é€šå¸¸ä½ æƒ³ä»…å…è®¸æŸäº›äººç™»å½•ã€‚

å¯ä»¥ä½¿ç”¨ `authorize(req, account)` å‡½æ•°å®ç°æ­¤ç›®çš„ï¼š

```javascript
const Privateparty = require('privateparty')
const allowed = [
  "0xab3b229eb4bcff881275e7ea2f0fd24eeac8c83a",
  "0x1ad91ee08f21be3de0ba2ba6918e714da6b45836",
  "0x829bd824b016326a401d083b33d092293333a830"
]
const party = new Privateparty()
party.add("user", {
  session: "/privateparty/session",
  connect: "/privateparty/connect",
  disconnect: "/privateparty/disconnect",
  authorize: async (req, account) => {
    if (!allowed.includes(account) {
      throw new Error("not allowed")
    }
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

è¯·æ³¨æ„ï¼š

1. æ·»åŠ ä¸€ä¸ªåä¸º `"user"`çš„ç»„
2. ç„¶ååœ¨ `party.app.get("/", party.auth("user", (req, res) => { . . . })` å¥æŸ„ç¨‹åºä¸­ä½¿ç”¨è¯¥ç»„ã€‚


##### 3. å¤šèº«ä»½éªŒè¯å¼•æ“

åœ¨ä¸‹é¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† 2 ä¸ªå¼•æ“ï¼š

1. userï¼šæ™®é€šç”¨æˆ·ç™»å½•æµç¨‹ã€‚ è¿è¡Œæ‰€æœ‰äººç™»å½•
2. adminï¼šç®¡ç†å‘˜ç”¨æˆ·ç™»å½•æµç¨‹ã€‚ æ£€æŸ¥å¸æˆ·æ˜¯å¦åŒ…å«åœ¨ ADMIN æ•°ç»„ä¸­ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™æŠ›å‡ºé”™è¯¯

```javascript
const Privateparty = require('privateparty')
const ADMINS = ["0x502b2fe7cc3488fcff2e16158615af87b4ab5c41"]
const party = new Privateparty()
party.add("user", {
  session: "/privateparty/session",
  connect: "/privateparty/connect",
  disconnect: "/privateparty/disconnect",
})
party.add("admin", {
  session: "/privateparty/admin/session",
  connect: "/privateparty/admin/connect",
  disconnect: "/privateparty/admin/disconnect",
  authorize: async (req, account) => {
    if (ADMINS.includes(account)) {
      return { admin: true }
    } else {
      throw new Error("not an admin")
    } 
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.get("/admin", party.auth("admin"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œæœ‰ä¸¤ä¸ª `GET` è·¯ç”±å¤„ç†ç¨‹åºï¼š

1. `GET /`ï¼šæ™®é€šç”¨æˆ·çš„æ­£å¸¸è·¯ç”±ã€‚ å› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ `auth("user")`ï¼Œæ‰€ä»¥å®ƒå°†ä½¿ç”¨ `user` ç»„ã€‚
2. `GET /admin`ï¼šç®¡ç†å‘˜å¯ä»¥ç™»å½•çš„é¡µé¢ã€‚ å› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ `auth("admin")`ï¼Œæ‰€ä»¥å®ƒå°†ä½¿ç”¨ `admin` ç»„ã€‚

### protect()

ä¸ auth() ç±»ä¼¼ï¼Œå¦å¤–å¦‚æœæœªæˆæƒï¼Œåˆ™ä¼šè‡ªåŠ¨é‡å®šå‘åˆ°å†…ç½®ç™»å½•é¡µé¢ã€‚

> `auth()` æ–¹æ³•åœ¨æœªæˆæƒæ—¶ `req.session` è¿”å›ä¸€ä¸ª`null` å€¼ï¼Œä»…æ­¤è€Œå·²ã€‚ `protect()` æ–¹æ³•é‡å®šå‘åˆ°ç™»å½•é¡µé¢ã€‚

è¦å°†ä¿æŠ¤é€»è¾‘æ·»åŠ åˆ°ä»»ä½•è·¯ç”±ï¼Œæ‚¨éœ€è¦ï¼š

1. é¦–å…ˆé€šè¿‡`add()`æ–¹æ³•å®šä¹‰ä¸€ä¸ªæˆæƒç»„åŠå…¶è¡Œä¸º
2. ç„¶åé€šè¿‡è°ƒç”¨ `party.protect(name)` æ¥ä½¿ç”¨è¯¥ç»„

#### è¯­æ³•


```javascript
party.protect(name, options)
```

ç¤ºä¾‹ç”¨æ³•:

```javascript
party.app.get(route1, party.protect(name), (req, res) => {
  ...
})
party.app.post(route2, party.protect(name), (req, res) => {
  ...
})
```



#### å‚æ•°

- `redirect`ï¼šæ³¨é”€æ—¶é‡å®šå‘çš„è·¯ç”±ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥è®¾ç½®ä¸€ä¸ªé¢å¤–çš„è·¯ç”±ï¼Œåœ¨æ³¨é”€æ—¶æ˜¾ç¤ºä¸€ä¸ªé¡µé¢ã€‚
  - `render`ï¼šæ³¨é”€æ—¶è¦æ¸²æŸ“çš„ HTML æ–‡ä»¶è·¯å¾„ã€‚
  - `json`ï¼šæ³¨é”€æ—¶è¿”å›çš„ JSON å¯¹è±¡ï¼Œä½œä¸º API è¯·æ±‚å‘å‡ºï¼ˆä¸æ˜¯ç½‘ç«™ï¼‰
  - `walletconnect`ï¼šWalletconnect Infura IDï¼Œæ”¯æŒç§»åŠ¨é’±åŒ…ã€‚
  - `fresh`ï¼šä½¿ç”¨é»˜è®¤ç™»å½•é¡µé¢æ—¶ï¼Œç™»å½•æ˜¯å¦è¦ä»é’±åŒ…åˆ—è¡¨ä¸­ï¼ˆé‡æ–°ï¼‰è¿æ¥ä¸€ä¸ªé’±åŒ…ï¼Œå¦‚æœä»ç„¶åœ¨è¿æ¥ï¼Œåˆ™ä½¿ç”¨ä¹‹å‰è¿æ¥çš„é’±åŒ…
    - å¦‚æœè®¾ç½® `true`ï¼Œç™»å½•æ˜¾ç¤ºåˆ—è¡¨ä¸­çš„æ‰€æœ‰é’±åŒ…ï¼Œå¹¶è®©ç”¨æˆ·é€‰æ‹©ä¸€ä¸ª
    - å¦‚æœè®¾ç½® `false`ï¼Œè·³è¿‡é’±åŒ…é€‰æ‹©æ­¥éª¤ï¼Œä½¿ç”¨ä¹‹å‰é€‰æ‹©çš„é’±åŒ…ï¼ˆè¿™æ˜¯é»˜è®¤è®¾ç½®ï¼‰

`redirect` å’Œ `render` é€‰é¡¹ä¹‹é—´çš„åŒºåˆ«åœ¨äºï¼Œ`redirect` å°†ç”¨æˆ·å‘é€åˆ°ä¸åŒçš„æŒ‡å®šè·¯ç”±ï¼ˆä¾‹å¦‚ `/login` è·¯ç”±ï¼‰ï¼Œè€Œ `render` ä¸ä¼šå°†ç”¨æˆ·å¸¦åˆ°ä»»ä½•å…¶ä»– URLï¼Œåªæ˜¾ç¤ºæä¾›çš„ HTMLã€‚

#### ç¤ºä¾‹

æœ¬èŠ‚ä¸­çš„æ‰€æœ‰ç¤ºä¾‹éƒ½ä¸ `auth()` ç¤ºä¾‹ç›¸åŒï¼Œåªæ˜¯ä½ ä½¿ç”¨çš„æ˜¯ `party.protect()` è€Œä¸æ˜¯ `party.auth()`ã€‚

##### 1. ç¼ºçœä¿æŠ¤

ä»¥ä¸‹ç¤ºä¾‹ä»…åŸºäºé’±åŒ…ç­¾åï¼Œæ¥å¯¹ç”¨æˆ·å¸æˆ·è¿›è¡Œèº«ä»½éªŒè¯ã€‚

```javascript
const party = new Privateparty()
party.add("user")
party.app.get("/", party.protect("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
```

1. `party.add("user"` å°†åˆ›å»ºä¸€ä¸ªåä¸º "user" çš„ç»„ï¼Œå®ƒä¼šè‡ªåŠ¨åˆ›å»ºä»¥ä¸‹è·¯ç”±ï¼š
     - `POST /privateparty/connect`
     - `POST /privateparty/disconnect`
     - `GET /privateparty/session`
2. ç„¶å express app å®ä¾‹ï¼ˆ`party.app`ï¼‰å¤„ç†`GET /`è¯·æ±‚ã€‚ åœ¨æ­¤ä¹‹å‰ï¼Œå®ƒä¼šé€šè¿‡ `party.protect("user")` ä¸­é—´ä»¶ã€‚
3. `party.add("user")` æœªæŒ‡å®šä»»ä½•æˆæƒé€»è¾‘ï¼Œæ‰€ä»¥å…è®¸æ‰€æœ‰è¯·æ±‚ã€‚
4. å› æ­¤ï¼Œå½“ç”¨æˆ·ç¬¬ä¸€æ¬¡è®¿é—®`/`è·¯ç”±æ—¶ï¼Œ`req.session`å°†ä¸ºç©ºï¼Œä½†æ˜¯...
5. å‰ç«¯è®¤è¯åï¼Œ`req.session` å°†åŒ…å« `{ "user": { "account": <user address> } }`

ä¸ `auth()` ç¤ºä¾‹ä¸åŒï¼Œå½“æ‚¨ç¬¬ä¸€æ¬¡è®¿é—® `/` è·¯ç”±æ—¶ï¼ŒPrivateparty ä¼šè‡ªåŠ¨å°†æ‚¨é‡å®šå‘åˆ°å…¶å†…ç½®çš„ç™»å½•é¡µé¢ã€‚

##### 2. æˆæƒ

ç¼ºçœæƒ…å†µä¸‹ï¼ŒPrivateparty å…è®¸æ‰€æœ‰äººç™»å½•ã€‚å¦‚æœåªå…è®¸æŸäº›äººç™»å½•ã€‚

å¯ä»¥ä½¿ç”¨ `authorize(req, account)` å‡½æ•°å®ç°æ­¤ç›®çš„ï¼š

```javascript
const Privateparty = require('privateparty')
const allowed = [
  "0xab3b229eb4bcff881275e7ea2f0fd24eeac8c83a",
  "0x1ad91ee08f21be3de0ba2ba6918e714da6b45836",
  "0x829bd824b016326a401d083b33d092293333a830"
]
const party = new Privateparty()
party.add("user", {
  session: "/privateparty/session",
  connect: "/privateparty/connect",
  disconnect: "/privateparty/disconnect",
  authorize: async (req, account) => {
    if (!allowed.includes(account) {
      throw new Error("not allowed")
    }
  }
})
party.app.get("/", party.protect("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

æ³¨æ„ï¼š

1. æ·»åŠ ä¸€ä¸ªåä¸º`"user"`çš„ç»„
2. ç„¶ååœ¨ `party.app.get("/", party.protect("user", (req, res) => { . . . })` å¥æŸ„ç¨‹åºä¸­ä½¿ç”¨ç»„ã€‚


##### 3. å¤šé‡ä¿æŠ¤å¼•æ“

å¦‚æœéœ€è¦ä¸ºä¸åŒçš„è§’è‰²æä¾›ä¸åŒçš„å†…å®¹ã€‚ å¯ä»¥ä½¿ç”¨å¼•æ“åˆ›å»ºè§’è‰²ã€‚

åœ¨ä¸‹é¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† 2 ä¸ªå¼•æ“ï¼š

1. userï¼šæ™®é€šç”¨æˆ·ç™»å½•æµç¨‹ã€‚ è®©æ‰€æœ‰äººç™»å½•
2. adminï¼šç®¡ç†å‘˜ç”¨æˆ·ç™»å½•æµç¨‹ã€‚ æ£€æŸ¥å¸æˆ·æ˜¯å¦åŒ…å«åœ¨ ADMIN æ•°ç»„ä¸­ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™æŠ›å‡ºé”™è¯¯

```javascript
const Privateparty = require('privateparty')
const ADMINS = ["0x502b2fe7cc3488fcff2e16158615af87b4ab5c41"]
const party = new Privateparty()
party.add("user", {
  session: "/privateparty/session",
    connect: "/privateparty/connect",
    disconnect: "/privateparty/disconnect",
  },
})
party.add("admin", {
  session: "/privateparty/admin/session",
  connect: "/privateparty/admin/connect",
  disconnect: "/privateparty/admin/disconnect",
  authorize: async (req, account) => {
    if (ADMINS.includes(account)) {
      return { admin: true }
    } else {
      throw new Error("not an admin")
    } 
  }
})
party.app.get("/", party.protect("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.get("/admin", party.protect("admin"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œæœ‰ä¸¤ä¸ª `GET` è·¯ç”±å¤„ç†ç¨‹åºï¼š

1.`GET /`ï¼šæ™®é€šç”¨æˆ·çš„æ­£å¸¸è·¯ç”±ã€‚ å› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ `party.protect("user")`ï¼Œæ‰€ä»¥å®ƒå°†ä½¿ç”¨ `user` ç»„ã€‚
2. `GET /admin`ï¼šç®¡ç†å‘˜å¯ä»¥ç™»å½•çš„é¡µé¢ã€‚ å› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ `party.protect("admin")`ï¼Œæ‰€ä»¥å®ƒå°†ä½¿ç”¨ `admin` ç»„ã€‚

##### 4. è‡ªå®šä¹‰æ³¨é”€æµç¨‹

é»˜è®¤æƒ…å†µä¸‹ï¼Œ`protect()` ä¿®é¥°ç¬¦ä¼šè‡ªåŠ¨å°†ç”¨æˆ·å‘é€åˆ°ç™»å½•é¡µé¢ï¼Œè®©ç”¨æˆ·ç™»å½•è¯¥è§’è‰²ã€‚

å¦‚æœä½ æƒ³è¦ä¸€ä¸ªè‡ªå®šä¹‰å¤„ç†ç¨‹åºï¼Œå¯ä»¥è¿™æ ·åšï¼š


```javascript
const Privateparty = require('privateparty')
const allowed = [
  "0xab3b229eb4bcff881275e7ea2f0fd24eeac8c83a",
  "0x1ad91ee08f21be3de0ba2ba6918e714da6b45836",
  "0x829bd824b016326a401d083b33d092293333a830"
]
const party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    if (!allowed.includes(account) {
      throw new Error("not allowed")
    }
  }
})
party.app.get("/login", (req, res) => {
  res.sendFile(__dirname + "/login.html")
})
party.app.get("/", party.protect("user", { redirect: "/login" } ), (req, res) => {
  console.log("session", req.session)
  res.sendFile(__dirname + "/index.html")
})
party.app.listen(3000)
```

æˆ–è€…ï¼Œå¦‚æœæ‚¨ä¸æƒ³å°†ç”¨æˆ·å‘é€åˆ°æ–°è·¯ç”±ï¼Œåªæƒ³æ˜¾ç¤ºé”™è¯¯ï¼Œå¯ä»¥ä½¿ç”¨ `render` é€‰é¡¹ï¼š

```javascript
const Privateparty = require('privateparty')
const allowed = [
  "0xab3b229eb4bcff881275e7ea2f0fd24eeac8c83a",
  "0x1ad91ee08f21be3de0ba2ba6918e714da6b45836",
  "0x829bd824b016326a401d083b33d092293333a830"
]
const party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    if (!allowed.includes(account) {
      throw new Error("not allowed")
    }
  }
})
party.app.get("/", party.protect("user", { render: __dirname + "/login.html" } ), (req, res) => {
  console.log("session", req.session)
  res.sendFile(__dirname + "/index.html")
})
party.app.listen(3000)
```

##### 5. Token ä»¤ç‰Œè®¤è¯

é™¤äº†ä½¿ç”¨å·²ç™»å½•ç”¨æˆ·çš„èº«ä»½éªŒè¯å‡­æ®è¿›è¡Œæˆæƒä¹‹å¤–ï¼Œæ‚¨è¿˜å¯ä»¥ä½¿ç”¨è®¿é—®ä»¤ç‰Œçš„è¿›è¡Œæˆæƒã€‚

ç¤ºä¾‹å¦‚ä¸‹ï¼š


```javascript
const party = new Privateparty()
party.add("user", {
  tokens: [
    "01127c36-32fa-4c85-b6da-f720796fe679",
    "35161a5c-60f0-4809-8b49-1a662247f5b3"
  ]
})
// Our JSON API endpoint
party.app.get("/api", party.protect("user"), (req, res) => {
  res.json({
    people: ["alice", "bob", "carol"]
  })
})
party.app.get("/", party.protect("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
```


è¿™å°†ï¼š

1. å…è®¸æ‰€æœ‰ç»è¿‡èº«ä»½éªŒè¯çš„ç”¨æˆ·ä½¿ç”¨cookiesç™»å½•æµè§ˆå™¨ï¼ˆå› ä¸ºæ²¡æœ‰`authorize()`å›è°ƒæ¥é™åˆ¶è®¿é—®
2. ä»…å…è®¸æ‹¥æœ‰è®¿é—®ä»£å¸ â€œ01127c36-32fa-4c85-b6da-f720796fe679â€ å’Œ â€œ35161a5c-60f0-4809-8b49-1a662247f5b3â€ çš„ç”¨æˆ·è®¿é—®åº”ç”¨ã€‚

è¦è¯·æ±‚ä»¤ç‰Œè®¤è¯ï¼Œæ‚¨éœ€è¦å°† HTTP è¯·æ±‚å¤´çš„ `Authorization` å­—æ®µè®¾ç½®ä¸º `token <ACCESS_TOKEN>`ã€‚ ä¾‹å­ï¼š

```javascript
fetch("https://protectedendpoint.com/api", {
  headers: {
    "Authorization": "token 01127c36-32fa-4c85-b6da-f720796fe679"
  }
}).then((r) => {
  return r.json()
}).then((r) => {
  console.log(r)
})
```

##### 6. æ‰‹æœºé’±åŒ…æ”¯æŒ

ä»¥ä¸‹ç¤ºä¾‹æ ¹æ®é’±åŒ…ç­¾åå¯¹ç”¨æˆ·å¸æˆ·è¿›è¡Œèº«ä»½éªŒè¯ã€‚

```javascript
const party = new Privateparty()
party.add("user")

// Use the walletconnect Inufra ID to support mobile wallets on the default login page
party.app.get("/", party.protect("user", { walletconnect: "667750972a89441ea5d276ed16d7eef0" }), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
```


### contract()

åˆ›å»ºå¹¶è¿”å›ä¸€ä¸ª web3 åˆçº¦æ–¹æ³•å¯¹è±¡ï¼Œå¯ä»¥é“¾æ¥è°ƒç”¨ web3 æ–¹æ³•ã€‚

#### è¯­æ³•

```javascript
const methods = party.contract(web3, abi, contract_address)
```

#### å‚æ•°

- `web3`: åˆå§‹åŒ–çš„ web3 å¯¹è±¡
- `abi`: ABI æ•°ç»„
- `contract_address`: åˆçº¦åœ°å€

#### ç¤ºä¾‹

##### 1. ä»£å¸ä½™é¢åˆçº¦è°ƒç”¨

è¦æ ¹æ®é’±åŒ…å¸æˆ·çš„çŠ¶æ€å’Œæ•°æ®æˆæƒç”¨æˆ·ï¼Œéœ€è¦æŸ¥è¯¢åŒºå—é“¾ã€‚

è¿™ç§æƒ…å†µä¸‹ï¼Œéœ€è¦å®ä¾‹åŒ–ä¸€ä¸ª web3 å¯¹è±¡å¹¶ä½¿ç”¨å†…ç½®çš„ `contract()` æ–¹æ³•æ¥è°ƒç”¨ web3 åˆçº¦æ–¹æ³•

```javascript
// Example. Use your own RPC URL
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
// Use your own JSON-RPC ENDPOINT instead of the URL below!
const web3 = createAlchemyWeb3("https://eth-mainnet.alchemyapi.io/v2/YAB7qBnOb0pceNn29u1v_PATpqKUN623")
let party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    const UNI = "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    const abi = [{
      "constant": true,
      "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ],
      "name": "balanceOf",
      "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }], UNI)
    const balance = await party.contract(web3, abi, UNI).balanceOf(account)
    if (balance >= 100) {
      return { balance } 
    } else {
      throw new Error("you need to own at least 100 $UNI)
    }
  }
})
```

æˆ–å¯ä»¥ä½¿ç”¨å†…ç½®çš„ `party.abi.erc721` è€Œä¸æ˜¯ç¡¬ç¼–ç  `const abi` ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```javascript
// Example. Use your own RPC URL
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
// Use your own JSON-RPC ENDPOINT instead of the URL below!
const web3 = createAlchemyWeb3("https://eth-mainnet.alchemyapi.io/v2/YAB7qBnOb0pceNn29u1v_PATpqKUN623")
let party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    const UNI = "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    const balance = await party.contract(web3, party.abi.erc721, UNI).balanceOf(account)
    if (balance >= 100) {
      return { balance } 
    } else {
      throw new Error("you need to own at least 100 $UNI)
    }
  }
})
```

##### 2. ç®¡ç†å‘˜ç™»å½•

æœ‰æ—¶ä½ æƒ³è¦æ„å»ºä¸€ä¸ªåªå…è®¸åˆçº¦æ‰€æœ‰è€…ç™»å½•çš„ç®¡ç†é¡µé¢ã€‚

é™¤äº† erc20 å’Œ erc721 ABI ä¹‹å¤–ï¼ŒPrivateparty è¿˜æœ‰ä¸€ä¸ªé€‚ç”¨äºåˆçº¦æ‰€æœ‰è€…çš„ ABI æ¥å£å¯ä»¥è°ƒç”¨ [ownable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol) ï¼š

```javascript
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
const web3 = createAlchemyWeb3(<YOUR JSON-RPC ENDPOINT URL>)
const party = new Privateparty()
party.add("admin", {
  session: "/privateparty/admin/session",
  connect: "/privateparty/admin/connect",
  disconnect: "/privateparty/admin/disconnect",
  authorize: async (req, account) => {
    const mfers = "0x79fcdef22feed20eddacbb2587640e45491b757f"
    let owner = await party.contract(web3, party.abi.ownable, mfers).owner().call()
    if (owner.toLowerCase() === account) {
      return { admin: true }
    } else {
      throw new Error("not an admin")
    }
  }
})
```

### abi

å¸¸ç”¨ ABI çš„å†…ç½®å¸¸ç”¨æ¨¡å—ï¼š

#### 1. erc20

```javascript
// ä½¿ç”¨ party.abi.erc20 è€Œä¸æ˜¯ç¡¬ç¼–ç  ABI
const party = new Privateparty()
let balance = await party.contract(web3, party.abi.erc20, UNISWAP_ADDRESS).balanceOf(account).call()
```

#### 2. erc721

```javascript
//ä½¿ç”¨ party.abi.erc721 è€Œä¸æ˜¯ç¡¬ç¼–ç  ABI
const party = new Privateparty()
let tokenURI = await party.contract(web3, party.abi.ownable, MFERS_NFT_ADDRESS).tokenURI(tokenId).call()
```

#### 3. ownable ï¼ˆæ‰€æœ‰è€…çš„ï¼‰

```javascript
// use the party.abi.ownable instead of hardcoding the ownable ABI
const party = new Privateparty()
let owner = await party.contract(web3, party.abi.ownable, mfers).owner().call()
```

### app

ä½¿ç”¨ `app = express()` åœ¨å†…éƒ¨åˆ›å»ºçš„ `app` å¯¹è±¡ã€‚

æ‚¨å¯ä»¥åƒä½¿ç”¨ä»»ä½• express app åº”ç”¨å®ä¾‹ä¸€æ ·ä½¿ç”¨ `app` å¯¹è±¡ã€‚

#### ç¤ºä¾‹

```javascript
const party = new Privateparty()
party.add("members", {
  authorize: async (req, account) => {
    // some membership checking logic
  }
})
party.app.get("/", (req, res) => {
  // public route.
  // no authentication and no authorization
})
party.app.get("/members", party("members"), (req, res) => {
  // members only logic
})
// Don't forget to start the app by listening to a port!
party.app.liten(3000)
```

### express

The expressjs module.



## æµè§ˆå™¨å®¢æˆ·ç«¯ 

### constructorï¼ˆæ„é€ å‡½æ•°ï¼‰

#### è¯­æ³•

```javascript
const party = new Privateparty(config)
```

#### å‚æ•°

- `config`ï¼šé…ç½®
   - `host`: **ï¼ˆå¯é€‰ï¼‰** å¦‚æœæ‚¨å¸Œæœ›å‘æ‰˜ç®¡åœ¨å¦ä¸€ä¸ª domoain ä¸Šçš„openavataræœåŠ¡å™¨å‘å‡ºè·¨åŸŸè¯·æ±‚ï¼Œè¯·æŒ‡å®šä¸»æœºã€‚
   - `walletconnect`ï¼š**ï¼ˆå¯é€‰ï¼‰** æŒ‡å®šæ­¤å­—æ®µä»¥æ”¯æŒç§»åŠ¨å’Œæ¡Œé¢é’±åŒ…ã€‚ `walletconnect` å±æ€§æ˜¯ [Walletconnect infuraId å±æ€§](https://github.com/Web3Modal/web3modal/blob/master/docs/providers/walletconnect.md?plain=1#L22) (è½¬åˆ° [Infura]( https://infura.io/) æ³¨å†Œå¹¶è·å– Infura é¡¹ç›® ID)ã€‚

#### è¿”å›å€¼

- `party`: å®ä¾‹åŒ–çš„OpenAvatarå®¢æˆ·ç«¯

#### ç¤ºä¾‹

##### 1. åŸºç¡€ç¤ºä¾‹

```javascript
const party = new Privateparty()
```

##### 2. è·¨åŸŸé“¾æ¥

å‡è®¾æ‚¨çš„openavataræœåŠ¡å™¨åœ¨ https://myprivatepartyserver.com ä¸Šè¿è¡Œ - æ‚¨å¯ä»¥ä½¿ç”¨ `host` å±æ€§è¿æ¥åˆ°å®ƒã€‚

> **æ³¨æ„**
>
> æ‚¨å¿…é¡»åœ¨æœåŠ¡å™¨ç«¯è®¾ç½® CORS æ”¯æŒæ‰èƒ½ä½¿å…¶æ­£å¸¸å·¥ä½œ http://localhost:56503/#/?id=_3-cross-origin-login-support
> 
```javascript
const party = new Privateparty({
  host: "https://myprivatepartyserver.com"
})
```


##### 3. ç§»åŠ¨å’Œæ¡Œé¢é’±åŒ…æ”¯æŒ

ä¸ºäº†æ”¯æŒæ‰‹æœºå’Œæ¡Œé¢é’±åŒ…ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨[Walletconnect](https://walletconnect.com/)ã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä» [Infura](https://infura.io) è·å–é¡¹ç›® ID å¹¶å°†å…¶è®¾ç½®ä¸º `walletconnect` å±æ€§ã€‚ ä¾‹å­ï¼š

```javascript
const party = new Privateparty({
  walletconnect: "27e484dcd9e3efcfd25a83a78777cdf1"   // ä½¿ç”¨ä½ è‡ªå·±çš„ INFURA ID!
})
```

---

### connect()

#### è¯­æ³•

```javascript
let session = await party.connect(name, payload, options)
```

#### å‚æ•°

- `name`ï¼šopenavatar è§’è‰²åç§°ã€‚ è‡ªåŠ¨è¿æ¥åˆ° openavatar åç«¯å®šä¹‰çš„åŒåç«¯ç‚¹ã€‚
- `payload`ï¼š**ï¼ˆå¯é€‰ï¼‰** å°†ä¼ é€’ç»™ Privateparty æœåŠ¡ç«¯çš„é™„åŠ æœ‰æ•ˆè´Ÿè½½ã€‚ Privateparty æœåŠ¡ç«¯å°†èƒ½å¤Ÿåœ¨å…¶æˆæƒé€»è¾‘ä¸­æ£€æŸ¥â€œreq.body.payloadâ€ã€‚
- `options`: **ï¼ˆå¯é€‰ï¼‰** ä¸€ä¸ªå¯¹è±¡æè¿°äº†å¦‚ä½•å»ºç«‹è¿æ¥ã€‚ åŒ…æ‹¬ä»¥ä¸‹å±æ€§ï¼š
   - `fresh`ï¼šæ˜¯å¦è¦æ±‚ç”¨æˆ·ï¼ˆé‡æ–°ï¼‰è¿æ¥é’±åŒ…åˆ—è¡¨ä¸­çš„é’±åŒ…ï¼Œå¦‚æœä»ç„¶åœ¨è¿æ¥ï¼Œåˆ™ä½¿ç”¨å…ˆå‰è¿æ¥çš„é’±åŒ…
     - å¦‚æœè®¾ç½® `true`ï¼Œæ˜¾ç¤ºåˆ—è¡¨é’±åŒ…ï¼Œå¹¶è®©ç”¨æˆ·é€‰æ‹©ä¸€ä¸ª
     - å¦‚æœè®¾ç½® `false`ï¼Œè·³è¿‡é’±åŒ…é€‰æ‹©æ­¥éª¤ï¼Œä½¿ç”¨ä¹‹å‰é€‰æ‹©çš„é’±åŒ…ï¼ˆè¿™æ˜¯é»˜è®¤è®¾ç½®ï¼‰
     - 
#### è¿”å›å€¼

- `session`ï¼šæ­¤è¿æ¥çš„å·²éªŒè¯å’Œå·²æˆæƒä¼šè¯å¯¹è±¡ã€‚
   - `account`ï¼šå·²éªŒè¯çš„å¸æˆ·
   - `expiresIn`ï¼šè‡ªå‘å¸ƒæ—¶é—´ (`iat`) ä»¥æ¥ï¼Œä¼šè¯æœ‰æ•ˆæ—¶é•¿ï¼Œä»¥ç§’ä¸ºå•ä½ã€‚ ï¼ˆé»˜è®¤ï¼š60 * 60 * 24 * 30ï¼Œæˆ– 30 å¤©ï¼‰
   - `jwt`ï¼šå®Œæ•´çš„ JWT å­—ç¬¦ä¸²
   - `auth`: **ï¼ˆå¯é€‰ï¼‰** å¦‚æœéœ€è¦ï¼Œç”±openavataræœåŠ¡å™¨è®¾ç½®çš„é™„åŠ å±æ€§ã€‚ ä»…å½“è°ƒç”¨ `party.add()` æ—¶ä» `authorize()` å›è°ƒè¿”å›æŸäº›å†…å®¹æ—¶æ‰åŒ…æ‹¬åœ¨å†…ã€‚

ç›¸åŒçš„ `session` å¯¹è±¡å°†å­˜å‚¨åœ¨ cookie ä¸­ï¼Œéšåå¯ä»¥é€šè¿‡ `party.session()` è®¿é—®

#### ç¤ºä¾‹

##### 1. åŸºæœ¬é“¾æ¥

å‡è®¾ Privatepartyå¯¹è±¡ åœ¨åç«¯æ·»åŠ äº†ä¸€ä¸ªåä¸ºâ€œuserâ€çš„è§’è‰²ï¼š

```javascript
const party = new Privateparty()
party.add("user")
party.app.get("/", party.auth("user"), (req, res) => {
  // public route.
  // no authentication and no authorization
})
party.app.listen(3000)
```

ä¸Šé¢ä»£ç è®¾ç½®é»˜è®¤ç«¯ç‚¹ï¼š

- `GET /privateparty/session`
- `POST /privateparty/connect`
- `POST /privateparty/disconnect`

å¯ä»¥ç®€å•åœ°é€šè¿‡æŒ‡å®šè§’è‰²çš„åç§°ï¼ˆ`"user"`ï¼‰è‡ªåŠ¨è¿æ¥åˆ°è¿™äº›ç«¯ç‚¹ï¼š


```javascript
// Browser code
const party = new Privateparty()
let session = await party.connect("user")
if (session) document.write("logged in: " + session.account)
```

##### 2. è‡ªå®šä¹‰å¼•æ“è¿æ¥

å¦‚æœåœ¨åç«¯è®¾ç½®äº†å¤šä¸ªå¼•æ“ï¼Œå¯ä»¥é€šè¿‡ä½¿ç”¨è‡ªå®šä¹‰ç«¯ç‚¹åˆå§‹åŒ– `Privateparty` å¯¹è±¡æ¥è¿æ¥åˆ°è‡ªå®šä¹‰ç«¯ç‚¹ã€‚

ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬ä»¥å¤šä¸ªè§’è‰²ï¼ˆâ€œuserâ€å’Œâ€œadminâ€ï¼‰ä¸ºä¾‹ï¼š

```javascript
const party = new Privateparty()

// "user" role
party.add("user")

// "admin" role
party.add("admin", {
  session: "/privateparty/admin/session",
  connect: "/privateparty/admin/connect",
  disconnect: "/privateparty/admin/disconnect",
  authorize: (req, account) => {
    const ADMIN = "0x502b2FE7Cc3488fcfF2E16158615AF87b4Ab5C41"
    if (account === ADMIN) {
      return { admin: true }
    } else {
      throw new Error("Not an admin")
    }
  }
})

// User UI
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})

// Admin UI
party.app.get("/admin", party.auth("admin"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/admin.html")
})
party.app.listen(3000)
```

æ¥ä¸‹æ¥ï¼Œåœ¨æµè§ˆå™¨ä¸­ï¼Œæˆ‘ä»¬å°è¯•ä»¥adminç®¡ç†å‘˜èº«ä»½ç™»å½•ï¼š

```javascript
const party = new Privateparty()
let session = await party.connect("admin")
```

The `party.connect("admin")`:

1. automatically discovers the `/admin/connect` endpoint
2. makes a POST request to it
3. the `authorize()` callback in the backend takes care of the authorization for the admin role

##### 3. ä½¿ç”¨è‡ªå®šä¹‰æœ‰æ•ˆè´Ÿè½½è¿›è¡Œèº«ä»½éªŒè¯

é€šå¸¸ï¼Œæˆæƒé€»è¾‘éœ€è¦çš„ä¸ä»…æ˜¯ç”¨æˆ·å¸æˆ·ã€‚ ä¾‹å¦‚ï¼Œç”¨æˆ·è¿˜å¯ä»¥ä½¿ç”¨ç‰¹å®šçš„ NFTï¼ˆ`tokenId` å’Œ `contract`ï¼‰è¿›è¡Œèº«ä»½éªŒè¯ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå‰ç«¯å°†æ›´å¤šæ•°æ®ä¼ é€’ç»™æœåŠ¡å™¨ç«¯ Privateparty å¯¹è±¡ã€‚ è¿™æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

```javascript
const party = new Privateparty()
await party.connect("user", {
  contract: "0x6866ed9a183f491024692971a8f78b048fb6b89b",
  tokenId: "55005454344647406361450320675654878134478584534017520891306338141495783002503"
})
```

æœåŠ¡å™¨å¯ä»¥åœ¨å¼•æ“ä¸­å®ç°ä¸€ä¸ª `authorize(req, account)` å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```javascript
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
const web3 = createAlchemyWeb3(<YOUR JSON-RPC ENDPOINT URL>)
const party = new Privateparty()
const { app, express, auth } = new Privateparty({
  engines: {
    user: {
      authorize: async (req, account) => {
        const collection = req.body.auth.contract
        const tokenId = req.body.auth.tokenId
        const abi = [{
          "inputs": [{ "internalType": "uint256", "name": "tokenId", "type": "uint256" }],
          "name": "ownerOf",
          "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
          "stateMutability": "view",
          "type": "function"
        }]
        let contract = new web3.eth.Contract(abi, collection)

        // allow login ONLY if the current account owns the tokenId
        let owner = await contract.methods.ownerOf(tokenId).call()
        if (owner.toLowerCase() === account.toLowerCase()) {
          return { tokenId, collection }
        } else {
          throw new Error("the user is not the token owner")
        }
      }
    }
  }
})
```

è¯·æ³¨æ„ï¼Œé™„åŠ çš„æœ‰æ•ˆè´Ÿè½½åŒ…å«åœ¨å±æ€§â€œreq.body.authâ€ä¸‹ã€‚

##### 4. è®©ç”¨æˆ·ä»é’±åŒ…ä¸­é€‰æ‹©ä¸€ä¸ªè´¦æˆ·

é»˜è®¤æƒ…å†µä¸‹ï¼ŒPrivateparty è‡ªåŠ¨ä½¿ç”¨ç¼ºçœå¸æˆ·ã€‚ å¦‚æœå…è®¸ç”¨æˆ·ä»é’±åŒ…ä¸­é€‰æ‹©ä¸åŒçš„å¸æˆ·è¿›è¡Œç™»å½•ã€‚

å¯ä»¥ç”¨ä¸‹ä¾‹æ–¹å¼è¿æ¥ï¼š

```javascript
const party = new Privateparty()
await party.connect("user", null, { fresh: true })
```

æ³¨æ„:

- ç¬¬äºŒä¸ªå‚æ•°æ˜¯ `null`ï¼ˆæ²¡æœ‰ä¼ é€’ä»»ä½•æœ‰æ•ˆè½½è·ï¼‰
- `connect()` æ–¹æ³•çš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼ˆ`options`ï¼‰æ˜¯`{fresh: true}`ã€‚ è¿™å‘Šè¯‰ openavatar å»ºç«‹ä¸€ä¸ªæ–°çš„è¿æ¥ï¼Œç”¨æˆ·å¯ä»¥ä»é’±åŒ…å¸æˆ·ä¸­è¿›è¡Œé€‰æ‹©ï¼Œè€Œä¸æ˜¯é€‰æ‹©ç¡®è®¤å¸æˆ·ã€‚

å½“ç„¶ï¼Œæ‚¨ä¹Ÿå¯ä»¥åœ¨ä¼ é€’æœ‰æ•ˆè´Ÿè½½çš„åŒæ—¶æ‰§è¡Œæ­¤æ“ä½œï¼š

```javascript
const party = new Privateparty()
await party.connect(
  "user",
  { contract: "0x6866ed9a183f491024692971a8f78b048fb6b89b", tokenId: "55005454344647406361450320675654878134478584534017520891306338141495783002503" },
  { fresh: true }
)
```

ç°åœ¨ç¬¬äºŒä¸ªå‚æ•°æ˜¯`payload`ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯`options`

---

### session()

`session()` æ–¹æ³•ç”¨äºè·å–å½“å‰ä¼šè¯ã€‚

#### è¯­æ³•

```javascript
let session = await party.session(name)
```

#### å‚æ•°

- `name`ï¼šä¼šè¯çš„è§’è‰²åç§°

#### è¿”å›å€¼

- `session`ï¼šæŒ‡å®šåç§°çš„å…¨å±€ä¼šè¯å¯¹è±¡
   - `account`ï¼šç»è¿‡èº«ä»½éªŒè¯çš„å¸æˆ·
   - `expiresIn`ï¼šè‡ªå‘å¸ƒæ—¶é—´ (`iat`) ä»¥æ¥ï¼Œä¼šè¯æœ‰æ•ˆæ—¶é•¿ï¼Œä»¥ç§’ä¸ºå•ä½ã€‚ ï¼ˆé»˜è®¤ï¼š60 * 60 * 24 * 30ï¼Œæˆ– 30 å¤©ï¼‰
   - `iat`: ä½•æ—¶å‘å‡ºçš„ä¼šè¯
   - `auth`: **ï¼ˆå¯é€‰ï¼‰** å¦‚æœéœ€è¦ï¼Œç”±openavataræœåŠ¡å™¨è®¾ç½®çš„é™„åŠ å±æ€§ã€‚ ä»…å½“è°ƒç”¨ `party.add()` æ—¶ä» `authorize()` å›è°ƒè¿”å›æŸäº›å†…å®¹æ—¶æ‰åŒ…æ‹¬åœ¨å†…ã€‚

#### ç¤ºä¾‹

```javascript
let session = await party.session("user")
console.log(session)
// The session may look something like:
//
//  {
//    account: "0x502b2FE7Cc3488fcfF2E16158615AF87b4Ab5C41",
//    auth: {
//      collection: "0x6866ed9a183f491024692971a8f78b048fb6b89b",
//      tokenId: "55005454344647406361450320675654878134478584534017520891306338141495783002503"
//    }
//  }


let admin_session = await party.session("admin")
console.log(admin_session)
// The admin_session may look something like:
//
//  {
//    account: "0x502b2FE7Cc3488fcfF2E16158615AF87b4Ab5C41",
//    auth: {
//      admin: true
//    }
//  }
//
```

---

### disconnect()

æ¸…é™¤ cookie å¹¶é€€å‡ºæ‰€æœ‰ä¼šè¯

#### è¯­æ³•

```javascript
await party.disconnect(name)
```

#### å‚æ•°

- `name`ï¼šè¦æ–­å¼€çš„ä¼šè¯çš„åç§°
- 
#### è¿”å›å€¼

- none

---

## Node.js å®¢æˆ·ç«¯

Privateparty å¯¹è±¡ä½¿ç”¨ [JWT](https://en.wikipedia.org/wiki/JSON_Web_Token)ï¼Œè¿™æ„å‘³ç€æ‚¨å¯ä»¥ä½¿ç”¨ä»æµè§ˆå™¨åˆ›å»ºçš„ç›¸åŒä¼šè¯ï¼Œå¹¶åœ¨æœåŠ¡å™¨è®¾ç½®æˆ–ä»»ä½•å…¶ä»–éæµè§ˆå™¨è®¾ç½®ä¸­ä½¿ç”¨å®ƒã€‚

ä»¥ä¸‹æ˜¯ node.js å®¢æˆ·ç«¯ä¸æµè§ˆå™¨å®¢æˆ·ç«¯çš„ä¸åŒä¹‹å¤„ï¼š

1. æ²¡æœ‰cookieï¼šä¸ partyconnect æµè§ˆå™¨å®¢æˆ·ç«¯ä¸åŒï¼Œå®ƒä¼šåœ¨è¿æ¥åè‡ªåŠ¨è®¾ç½®cookieï¼Œè€Œ`partypass` node.js å®¢æˆ·ç«¯åªæ˜¯å‘  openavatar æœåŠ¡ç«¯å‘å‡ºè¯·æ±‚ä»¥åˆ›å»ºJWT ä»¤ç‰Œã€‚ä»æ­¤æ—¶ï¼Œå¦‚ä½•å¤„ç† JWT ä»¤ç‰Œç”±ä½ å†³å®šã€‚
2. ç›´æ¥ä½¿ç”¨ç§é’¥ï¼š`partyconnect`æµè§ˆå™¨å®¢æˆ·ç«¯æ˜¯ä¸ºæµè§ˆå™¨æ— ç¼åº”ç”¨è€Œæ„å»ºçš„ï¼Œå› æ­¤ä½¿ç”¨æ³¨å…¥æµè§ˆå™¨çš„ä»»ä½•é’±åŒ…ã€‚ä½†æ˜¯ `partypass` node.js å®¢æˆ·ç«¯ä¸»è¦åº”è¯¥è¿è¡Œåœ¨ node.js è®¾ç½®ä¸­ï¼Œå¹¶ä¸”æ²¡æœ‰æ³¨å…¥æµè§ˆå™¨é’±åŒ…ã€‚å› æ­¤ï¼Œè¦åˆå§‹åŒ– `partypass`ï¼Œæ‚¨å¿…é¡»ä¼ é€’ä¸€ä¸ªç§é’¥ï¼Œè¯¥ç§é’¥å°†ç”¨äºå¯¹æ¶ˆæ¯è¿›è¡Œç­¾åã€‚

åŸºæœ¬ä¸Šï¼Œâ€œpartyconnectâ€åº“ä¸»è¦ç”¨äºæµè§ˆå™¨å†…ä½¿ç”¨ï¼Œè€Œâ€œpartypassâ€æ˜¯ä½¿ç”¨æ‚¨æä¾›çš„ç§é’¥åˆ›å»º JWT çš„æœ€å°åº“ã€‚

### æ„é€ å‡½æ•°

#### è¯­æ³•

```javascript
const pass = new Partypass(config)
```

#### å‚æ•°

- `config`
   - `host`ï¼šopenavatarä¸»æœº URL
   - `key`ï¼š åå…­è¿›åˆ¶å½¢å¼çš„ç§é’¥ï¼ˆæ²¡æœ‰`0x`å‰ç¼€ï¼‰
   - 
#### è¿”å›å€¼

- `pass`: åˆå§‹åŒ–çš„partypasså¯¹è±¡ï¼Œå¯ä»¥ç”¨æ¥åˆ›å»ºä¼šè¯

#### ç¤ºä¾‹

```javascript
const pass = new Partypass({
  host: "http://localhost:3000",
  key: "cd76c32ffeae94b725b40b1f58ffc793d5b0e96596f8d067f29d385894f16424" // private key
})
```

åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä¸åº”ç¡¬ç¼–ç ç§é’¥ï¼Œå› æ­¤ä»£ç å®é™…ä¸Šå¯èƒ½å¦‚ä¸‹ï¼š

```javascript
const pass = new Partypass({
  host: "http://localhost:3000",
  key: process.env.PRIVATE_KEY  // use environment variables
})
```

### create()

ä½¿ç”¨åˆå§‹åŒ–çš„ Partypass å¯¹è±¡åˆ›å»ºä¼šè¯

> `await pass.create(name, payload)` ç­‰ä»·äº `await pass.request(await pass.build(name), payload)`
> 
#### è¯­æ³•

```javascript
const session = await pass.create(name, payload)
```

#### å‚æ•°

- `name`ï¼šè§’è‰²çš„åç§°ã€‚ è‡ªåŠ¨è¿æ¥åˆ°æœåŠ¡ç«¯å®šä¹‰çš„åŒåç«¯ç‚¹ã€‚
- `payload`ï¼š**ï¼ˆå¯é€‰ï¼‰** ä¼ é€’ç»™ Privateparty æœåŠ¡å™¨å¯¹è±¡çš„é™„åŠ æœ‰æ•ˆè´Ÿè½½ã€‚ Privateparty æœåŠ¡å™¨å¯¹è±¡å°†èƒ½å¤Ÿåœ¨å…¶æˆæƒé€»è¾‘ä¸­æ£€æŸ¥â€œreq.body.payloadâ€ã€‚

#### è¿”å›å€¼

- `session`ï¼šç»è¿‡èº«ä»½éªŒè¯å’Œæˆæƒçš„ä¼šè¯å¯¹è±¡ã€‚
   - `account`ï¼šç»è¿‡èº«ä»½éªŒè¯çš„å¸æˆ·
   - `expiresIn`ï¼šè‡ªå‘å¸ƒæ—¶é—´ (`iat`) ä»¥æ¥ï¼Œä¼šè¯æœ‰æ•ˆæ—¶é•¿ï¼Œä»¥ç§’ä¸ºå•ä½ã€‚ ï¼ˆé»˜è®¤ï¼š60 * 60 * 24 * 30ï¼Œæˆ– 30 å¤©ï¼‰
   - `jwt`ï¼šå®Œæ•´çš„ JWT å­—ç¬¦ä¸²
   - `auth`: **ï¼ˆå¯é€‰ï¼‰** å¦‚æœéœ€è¦ï¼Œç”±æœåŠ¡å™¨è®¾ç½®çš„é™„åŠ å±æ€§ã€‚ ä»…å½“æ‚¨åœ¨è°ƒç”¨ `party.add()` æ—¶ä» `authorize()` å›è°ƒè¿”å›æŸäº›å†…å®¹æ—¶æ‰åŒ…æ‹¬åœ¨å†…ã€‚

ç›¸åŒçš„ `session` å¯¹è±¡å°†å­˜å‚¨åœ¨ cookie ä¸­ï¼Œéšåå¯ä»¥é€šè¿‡ `party.session()` è®¿é—®

#### ç¤ºä¾‹

å‡è®¾ Privateparty æœåŠ¡ç«¯å¯¹è±¡ æ·»åŠ äº†ä¸€ä¸ªåä¸ºâ€œuserâ€çš„è§’è‰²ï¼š

```javascript
// server.js
const party = new Privateparty()
party.add("user")
party.app.get("/", party.auth("user"), (req, res) => {
  // public route.
  // no authentication and no authorization
})
party.app.listen(3000)
```

ç°åœ¨åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œå‘ä¸Šé¢çš„PrivatepartyæœåŠ¡å™¨å¯¹è±¡å‘å‡ºè¯·æ±‚ï¼Œä½œä¸º`client.js`ï¼š

```javascript
// client.js
const Partypass = require('partypass')
const pass = new Partypass({
  host: "http://localhost:3000",
  key: "cd76c32ffeae94b725b40b1f58ffc793d5b0e96596f8d067f29d385894f16424" // replace with your private key
})
let session = await pass.create("user")
console.log(session)
```

è¿è¡Œ â€œnode å®¢æˆ·ç«¯â€ã€‚ è·å¾—åŒ…å« JWT çš„ä¼šè¯å¯¹è±¡ã€‚


### session()

æ£€æŸ¥ä¼šè¯æ˜¯å¦å·²è¿‡æœŸ

#### è¯­æ³•

```javascript
const session = await pass.session(name)
```

#### å‚æ•°

- `name`: è§’è‰²çš„åç§°

#### è¿”å›å€¼

- `session`: è¿”å› `name` è§’è‰²çš„ä¼šè¯ä¿¡æ¯ã€‚ å¦‚æœè¿‡æœŸï¼Œåˆ™è¿”å› `null`ã€‚

### build()

æ„å»ºä¸€ä¸ªç­¾åè¯·æ±‚ä»¥å‘é€åˆ° openavatar æœåŠ¡å™¨ã€‚

>  `create()` è°ƒç”¨ç­‰æ•ˆäºè°ƒç”¨ `build()` + ç»§ç»­è°ƒç”¨ `request()`
> 
#### è¯­æ³•

```javascript
const req = await pass.build(name)
```

#### å‚æ•°

- `name`: è§’è‰²åç§°
- 
#### è¿”å›å€¼

- `req`ï¼šå‡†å¤‡å¥½çš„è¯·æ±‚å¯¹è±¡ã€‚ å¯ä»¥å‘é€åˆ°ç›¸å…³çš„openavatar æœåŠ¡å™¨ï¼ˆå³å·²è¿æ¥ä¸»æœºï¼‰
   - `str`ï¼šå·²ç­¾åçš„ nonce æ¶ˆæ¯
   - `sig`ï¼šç­¾åï¼ˆä¸ªäººç­¾åï¼‰
   - `url`ï¼šè¯·æ±‚å‘é€åˆ°çš„ç«¯ç‚¹


### request()

å‘é€ä½¿ç”¨ `build()` æ–¹æ³•åˆ›å»ºçš„æ„å»ºè¯·æ±‚ï¼Œä»¥ä»openavataræœåŠ¡å™¨è·å–ç›¸åº”çš„ä¼šè¯

#### è¯­æ³•

```javascript
const session = await pass.request(req, payload)
```

#### å‚æ•°

- `req`ï¼šä½¿ç”¨`pass.build()`åˆ›å»ºçš„å‡†å¤‡å¥½çš„è¯·æ±‚å¯¹è±¡ã€‚ å¯ä»¥å‘é€åˆ°ç›¸å…³çš„openavataræœåŠ¡å™¨ï¼ˆä¸å·²è¿æ¥ä¸»æœºç›¸åŒçš„ä¸»æœºï¼‰
   - `str`ï¼šå·²ç­¾åçš„ nonce æ¶ˆæ¯
   - `sig`ï¼šç­¾åï¼ˆä¸ªäººç­¾åï¼‰
   - `url`ï¼šå°†è¯·æ±‚å‘é€åˆ°çš„ç«¯ç‚¹
- `payload`: **ï¼ˆå¯é€‰ï¼‰** ä¸€ä¸ªé¢å¤–çš„æœ‰æ•ˆè½½è·å‘é€åˆ°æœåŠ¡ç«¯ã€‚

#### è¿”å›å€¼

- `session`ï¼šè¿”å›`name`è§’è‰²åˆ›å»ºçš„ä¼šè¯ä¿¡æ¯ã€‚
   - `account`ï¼šç»è¿‡èº«ä»½éªŒè¯çš„å¸æˆ·
   - `expiresIn`ï¼šè‡ªå‘å¸ƒæ—¶é—´ (`iat`) ä»¥æ¥ï¼Œä¼šè¯æœ‰æ•ˆæ—¶é•¿ï¼Œä»¥ç§’ä¸ºå•ä½ã€‚ ï¼ˆé»˜è®¤ï¼š60 * 60 * 24 * 30ï¼Œæˆ– 30 å¤©ï¼‰
   - `jwt`ï¼šå®Œæ•´çš„ JWT å­—ç¬¦ä¸²
   - `auth`: **ï¼ˆå¯é€‰ï¼‰** å¦‚æœéœ€è¦ï¼Œç”±openavatarè®¾ç½®çš„é™„åŠ å±æ€§ã€‚ ä»…å½“è°ƒç”¨ `party.add()` æ—¶ä» `authorize()` å›è°ƒè¿”å›æŸäº›å†…å®¹æ—¶æ‰åŒ…æ‹¬åœ¨å†…ã€‚