# ç®€ä»‹

## ä»€ä¹ˆæ˜¯ OpenAvatar-SDK ?

OpenAvatar æ˜¯å…¨çƒç¬¬ä¸€ä¸ªå¯è§†åŒ– Web3 DIDåè®®

OpenAvatar-SDK æ˜¯ OPENAVATAR çš„ä¸€ä¸ªå¼€æºç»„ä»¶ï¼Œå®ƒæ˜¯ä»Privatepartyåº“æ´¾ç”Ÿçš„ï¼Œæ˜¯ä¸€ä¸ªå¼€æºæ¡†æ¶ï¼Œå¯ä»¥éå¸¸å®¹æ˜“åœ°æ„å»ºåŒºå—é“¾è®¤è¯çš„ Web3 åº”ç”¨ç¨‹åºã€‚

åªéœ€å‡ è¡Œä»£ç ï¼Œæ‚¨å°±å¯ä»¥æ„å»ºå…·æœ‰éå¸¸å¤æ‚çš„é’±åŒ…èº«ä»½éªŒè¯/æˆæƒé€»è¾‘çš„ Web åº”ç”¨ç¨‹åºã€‚

![ppclient.png](ppclient.png)

The result:

![login.gif](login.gif)


1. **èº«ä»½éªŒè¯ï¼š** ä½¿ç”¨åŒºå—é“¾é’±åŒ…ç­¾åç™»å½•
2. **æˆæƒï¼š** æ ¹æ®åŒºå—é“¾çŠ¶æ€æˆ–é“¾ä¸‹æŸ¥è¯¢æˆæƒè®¿é—®æ‚¨çš„é¡µé¢
3. **ç®€å•ï¼š** åªéœ€ä¸€è¡Œ JavaScript ä»£ç å³å¯è®¾ç½®ã€‚ æ²¡æœ‰å¤æ‚çš„æ­¥éª¤ã€‚
4. **å¼€æºï¼š** å®ƒæ˜¯ä¸€ä¸ª 100% å¼€æºæ¡†æ¶ï¼Œæ²¡æœ‰ç¬¬ä¸‰æ–¹APIã€‚

## ä½ èƒ½ç”¨ OpenAvatar-SDK åšä»€ä¹ˆ?

OpenAvatar-SDK åªæ˜¯ç”¨å¯†ç å­¦å’ŒåŒºå—é“¾çŠ¶æ€å–ä»£äº†ä¼ ç»Ÿçš„èº«ä»½éªŒè¯æ–¹æ³•ã€‚

è¿™æ„å‘³ç€æ‚¨å¯ä»¥æ„å»ºä»»ä½•æ‚¨å¯ä»¥æƒ³è±¡çš„åº”ç”¨ã€‚ æ‚¨åªæ˜¯ç”¨ OpenAvatar-SDK æ›¿æ¢ä¼ ç»Ÿçš„ç”¨æˆ·æ•°æ®åº“ã€‚

1. **ç®€å•çš„èº«ä»½éªŒè¯ï¼š** é€‚åˆçŸ¥é“å½“å‰ç™»å½•é’±åŒ…è´¦æˆ·çš„çš„Web3åº”ç”¨ç¨‹åºï¼ˆå…è®¸ä»»ä½•äººä½¿ç”¨é’±åŒ…ç™»å½•ï¼‰
2. **ä»…é™é‚€è¯·çš„åº”ç”¨ç¨‹åºï¼š** ä»…å…è®¸åœ°å€åˆ—è¡¨ä¸­çš„äººç™»å½•
3. **åŸºäº NFT çš„æˆæƒï¼š** ä»…å…è®¸åŸºäºé’±åŒ…æ‹¥æœ‰çš„ NFT æ‰€æœ‰æƒç™»å½•
4. **åŸºäº ERC20 çš„æˆæƒï¼š** ä»…å…è®¸åŸºäºé’±åŒ…æ‹¥æœ‰çš„ ERC20 ä»£å¸ç™»å½•
5. **ç©ºæŠ•ï¼š** å¯ä»¥é€šè¿‡ä»…æˆæƒæ›¾ç»ä¸æŸä¸ªåˆçº¦äº¤äº’è¿‡çš„åœ°å€æ¥å®æ–½ç©ºæŠ•ã€‚
6. **Moreï¼š** åŸºæœ¬ä¸Šå¯ä»¥æ ¹æ®ä»»ä½•åŒºå—é“¾æŸ¥è¯¢å®ç°æˆæƒã€‚


## ç¤¾ç¾¤æ”¯æŒ

æé—®æˆ–åé¦ˆï¼š:

1. Twitter: https://twitter.com/skogard
2. Discord: https://discord.gg/BZtp5F6QQM
3. GitHub: https://github.com/privatepart

---


# å¿«é€Ÿå…¥é—¨

## 1. Server
æœåŠ¡ç«¯æœ‰ä¸¤ä¸ªæ­¥éª¤è¦åšï¼š

1. **è®¾ç½®åç«¯ï¼š** `privateparty` æ¨¡å—è®©æ‚¨è½»æ¾è®¾ç½®å—åŒºå—é“¾é’±åŒ…ç­¾åä¿æŠ¤çš„ [express.js]æœåŠ¡å™¨(https://expressjs.com/) ã€‚
2. **è¿æ¥åˆ°åç«¯ï¼š** è®¾ç½®åç«¯åï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `partyconnect` åº“ä»æµè§ˆå™¨è¿æ¥åˆ°å®ƒã€‚

é¦–å…ˆå®‰è£…ä¾èµ–

```
npm install privateparty
```

æ¥ç€åˆ›å»ºä¸€ä¸ªåä¸º `index.js` çš„æ–‡ä»¶å¹¶ç¼–å†™åˆå§‹åŒ–é€»è¾‘ï¼š

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty()

// create a "user" group
party.add("user")

// authenticate using the "user" group.
party.app.get("/", party.auth("user"), (req, res) => {

  // the 'req.session' will be an empty object before the user authenticates
  console.log("session", req.session)

  // serve the index.html file to the public
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

## 2. Client

ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä¸æœåŠ¡å™¨ç«¯é€šä¿¡çš„æ–‡ä»¶ `index.html`ï¼š

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <button></button>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  // Get the "user" session
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  try {
    // Get the "user" session
    let session = await party.session("user")
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    // display error if something went wrong
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```

## 3. å¯åŠ¨ App

è¿è¡Œå‘½ä»¤:

```
node index
```

æ‰“å¼€æµè§ˆå™¨é“¾æ¥ http://localhost:3000 

å°±ä¼šçœ‹åˆ°ä¸‹é¢çš„ç»“æœï¼Œï¼š

![desktoplogin.gif](desktoplogin.gif)

## 4. æ”¯æŒæ‰‹æœºç§»åŠ¨é’±åŒ…

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åˆšåˆšä½¿ç”¨äº†æ¡Œé¢æµè§ˆå™¨ä¸Šå®‰è£…çš„é»˜è®¤é’±åŒ…ï¼ˆMetamaskï¼‰ã€‚ ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•æ”¯æŒç§»åŠ¨é’±åŒ…ã€‚

ä¸ºäº†æ”¯æŒç§»åŠ¨é’±åŒ…ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ [Walletconnect](https://walletconnect.com/)ã€‚ æ‚¨æ— éœ€å­¦ä¹ å¦‚ä½•ä½¿ç”¨ Walletconnectã€‚ åœ¨åˆ›å»º `Privateparty` å®ä¾‹æ—¶ï¼Œæ‚¨åªéœ€è¦ä¼ é€’ä¸€ä¸ªåä¸º `walletconnect` çš„å±æ€§ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```javascript
const party = new Privateparty({
  walletconnect: <Your Infura Key>
})
```

é¦–å…ˆæ³¨å†Œ [Infura](https://infura.io) ï¼Œåˆ›å»ºä¸€ä¸ªé¡¹ç›®å¹¶è·å–é¡¹ç›® IDã€‚

ç„¶åè®©æˆ‘ä»¬å›åˆ°ä¸Šé¢çš„å‰ç«¯ä¾‹å­ï¼Œåœ¨åˆå§‹åŒ– `Privateparty` å®ä¾‹æ—¶åªä¼ é€’ `walletconnect` å±æ€§ï¼š

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <button></button>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty({
  walletconnect: <USE YOUR OWN INFURA KEY>
})
const render = async () => {
  // Get the "user" session
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  try {
    // Get the "user" session
    let session = await party.session("user")
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    // display error if something went wrong
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```
æ³¨æ„ Walletconnect æ— æ³•åœ¨ localhost ä¸Šè¿è¡Œï¼Œå› æ­¤æ‚¨éœ€è¦è·å– HTTPS URL è¿›è¡Œæµ‹è¯•ã€‚ æ‚¨å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼åšåˆ°è¿™ä¸€ç‚¹ï¼š

1. å°†ç«™ç‚¹å…¬å¼€éƒ¨ç½²åˆ° HTTPS åŸŸï¼ˆæ‰€æœ‰ Web æ‰˜ç®¡æœåŠ¡æä¾›å•†é»˜è®¤æ”¯æŒæ­¤åŠŸèƒ½ï¼‰
  
2. ä½¿ç”¨ [ngrok](https://ngrok.com/) æˆ– [localtunnel](https://theboroer.github.io/localtunnel-www/) ç­‰è¿›è¡Œæœ¬åœ°æµ‹è¯•

è®©æˆ‘ä»¬å°è¯•ç¬¬äºŒç§æ–¹æ³•å¹¶ä½¿ç”¨ localtunnel åœ¨æœ¬åœ°è¿›è¡Œæµ‹è¯•ã€‚ éœ€è¦éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š

1.å¯åŠ¨privatepartyæœåŠ¡å™¨ï¼š`node index`

2.å¯åŠ¨ä¸€ä¸ªæŒ‡å‘privatepartyæœåŠ¡å™¨çš„localtunnelï¼š`npx lt --port 3000`

è¿™å°†ä¸ºæ‚¨æä¾›ä¸€ä¸ªå¯ä»¥æµ‹è¯•çš„å…¬å…± HTTPS ç½‘å€ã€‚ å°†å…¶å¤åˆ¶å¹¶ç²˜è´´åˆ°æµè§ˆå™¨ä¸­ã€‚ æ‚¨å°†çœ‹åˆ°ç±»ä¼¼äºä»¥ä¸‹åŠ¨ç”»çš„å†…å®¹ï¼ˆè¿™é‡Œæ¼”ç¤ºäº†ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„ç§»åŠ¨é’±åŒ… Metamask mobile å’Œ Rainbow é’±åŒ…ç™»å½•ï¼‰ï¼š

![mobilelogin.gif](mobilelogin.gif)

## 5. æ›´ç®€å•çš„èº«ä»½éªŒè¯

ä¸Šé¢ç¤ºä¾‹æ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨ JavaScript ä»¥ç¼–ç¨‹æ–¹å¼ç™»å½•æˆ–æ³¨é”€ã€‚

è¿˜æœ‰ä¸€ç§æ›´ç®€å•çš„æ–¹æ³•æ¥å®ç°ç™»å½•ï¼šåªéœ€åŒ…å«ä¸€ä¸ªé“¾æ¥ï¼ˆğŸ‘‡ğŸ»ä¸‹é¢ç¤ºæ„ï¼‰å°±å¯ä»¥å·¥ä½œï¼š

```
<a href="/privateparty/gate/user">Login</a>
```

å®ƒå°†ç”¨æˆ·å‘é€åˆ°å†…ç½®çš„ **"gate"** é¡µé¢ï¼Œè¯¥é¡µé¢ä¼šè‡ªåŠ¨å¤„ç†ç™»å½•å’Œæ³¨é”€ï¼Œå¹¶åœ¨å¤„ç†å®Œç™»å½•/æ³¨é”€åå°†ç”¨æˆ·è¿”å›ã€‚

è¦äº†è§£å¦‚ä½•æ‰§è¡Œæ­¤æ“ä½œï¼Œè¯·æŸ¥çœ‹â€œ[One-liner login/logout](#one-liner-loginlogout)â€éƒ¨åˆ†ã€‚

![gate.gif](gate.gif)

---

# ç¤ºä¾‹

## ä»…é‚€è¯·åº”ç”¨

ä»…å…è®¸æŒ‡å®šåœ°å€ç™»å½•ã€‚

### æœåŠ¡å™¨

å…ˆå®‰è£…ä¾èµ–

```
npm install privateparty
```

æ¥ç€åˆ›å»ºä¸€ä¸ªåä¸º `index.js` çš„æ–‡ä»¶å¹¶ç¼–å†™åˆå§‹åŒ–é€»è¾‘ï¼š

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty()
const MEMBERS = [
  "0xfb7b2717f7a2a30b42e21cef03dd0fc76ef761e9",
  "0x502b2fe7cc3488fcff2e16158615af87b4ab5c41"
]
party.add("user", {
  authorize: async (req, account) => {
    if (MEMBERS.includes(account)) {
      // if the account is part of the MEMBERS array, the account is authorized.
      // when authorized, the session will look like:
      //
      //  {
      //    account: <account>,
      //    auth: {
      //      member: true
      //    }
      //  }
      return { member: true }
    } else {
      throw new Error("not on the list!") 
    }
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

### å®¢æˆ·ç«¯

ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä¸æœåŠ¡å™¨é€šä¿¡çš„æ–‡ä»¶ï¼š`index.html`

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <button></button>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  try {
    let session = await party.session("user")
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```


## ERC20 é—¨æ§åº”ç”¨

æœ‰æ—¶ï¼Œæ‚¨å¯èƒ½å¸Œæœ›ç”¨æˆ·ä½¿ç”¨é’±åŒ…ç™»å½•ï¼Œå¹¶å­˜å‚¨æŒ‡å®š ERC20 ä»£å¸ä½™é¢ã€‚

è¿™å¯¹äºæ­å»ºç©ºæŠ•ç½‘ç«™ï¼Œæˆ–è®¸å¤šå…¶ä»–ç›®çš„çš„åº”ç”¨æ—¶ï¼Œå¯èƒ½å¾ˆæœ‰ç”¨ã€‚

### å®¢æˆ·

è®©æˆ‘ä»¬é¦–å…ˆæ­å»ºå‰ç«¯ã€‚ å…ˆåˆ›å»ºä¸€ä¸ªä¸æœåŠ¡å™¨é€šä¿¡çš„æ–‡ä»¶ï¼š `index.html` 

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <button></button>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  try {
    let session = await party.session("user")
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```


### Server

å¯¹äºè¿™ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å°†ï¼š

1. å…è®¸ä»»ä½•äººç™»å½•ã€‚
2. åœ¨åŒºå—é“¾ä¸­æŸ¥è¯¢ä»–ä»¬çš„ UNISWAP ä»£å¸ ($UNI) ä½™é¢ï¼Œå¹¶é€šè¿‡ cookie å°†å…¶ä¿å­˜ç”¨äºåç»§è®¿é—®ã€‚

ç”±äºæˆ‘ä»¬å°†æŸ¥è¯¢åŒºå—é“¾ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä½¿ç”¨ JSON-RPC ç«¯ç‚¹ã€‚


#### 1. å¤æ‚çš„æ–¹å¼

é¦–å…ˆå®‰è£…ä¾èµ–

```
npm install privateparty @alch/alchemy-web3
```

ç°åœ¨åˆ›å»ºä¸€ä¸ªåä¸º `index.js` çš„æ–‡ä»¶å¹¶ç¼–å†™åˆå§‹åŒ–é€»è¾‘ï¼š

```javascript
///////////////////////////////////////////////////////////////////////////////////////////
//
//  When a user logs in, take a snapshot of an ERC20 token balance and store it in cookie
//
///////////////////////////////////////////////////////////////////////////////////////////
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
const web3 = createAlchemyWeb3(<YOUR JSON-RPC ENDPOINT URL>)
const party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    const UNI = "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    let contract = new web3.eth.Contract([{
      "constant": true,
      "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ],
      "name": "balanceOf",
      "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }], UNI)
    let balance = await contract.methods.balanceOf(account).call()

    // Returning the additional attribute 'balance' will automatically set the value on the cookie
    // under the "auth" attribute
    return {
      balance: balance
    }
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```


ç”±äº `authorize()` å‡½æ•°ä¸ä¼šæŠ›å‡ºä»»ä½•é”™è¯¯ï¼Œè€Œåªä¼šè¿”å›ä½™é¢å¯¹è±¡ï¼Œå› æ­¤æ­¤åº”ç”¨ç¨‹åºå°†å…è®¸ä»»ä½•äººç™»å½•ï¼Œä½†ä½¿ç”¨ä½™é¢ä¿¡æ¯æ¥è¯†åˆ«ç”¨æˆ·ï¼ˆä¾‹å¦‚ï¼ŒæŒæœ‰äººå°†æ‹¥æœ‰éé›¶ä½™é¢ï¼Œè€Œ éæŒæœ‰è€…çš„ä½™é¢ä¸º0ï¼‰

#### 2. ç®€å•çš„æ–¹å¼

ç”±äº ERC20 å’Œ ERC721 æ˜¯å¸¸ç”¨çš„æ ‡å‡†ï¼ŒPrivateparty æä¾›äº†ä¸€ä¸ªå†…ç½®çš„ ABIï¼Œæ‚¨å¯ä»¥åˆ†åˆ«åœ¨ `party.abi.erc20` å’Œ `party.abi.erc721` ä¸‹è®¿é—®ã€‚

ä¸Šé¢å®Œå…¨ç›¸åŒçš„ä»£ç å¯ä»¥é‡å†™å¦‚ä¸‹ï¼š

```javascript
///////////////////////////////////////////////////////////////////////////////////////////
//
//  å½“ç”¨æˆ·ç™»å½•æ—¶ï¼Œè·å–ERC20ä»£å¸ä½™é¢ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨ cookie ä¸­
//
///////////////////////////////////////////////////////////////////////////////////////////
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
const web3 = createAlchemyWeb3(<YOUR JSON-RPC ENDPOINT URL>)
const party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    const UNI = "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    let balance = await party.contract(web3, party.abi.erc20, UNI).balanceOf(account).call()
    return {
      balance: balance
    }
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```


## NFT æ§åˆ¶åº”ç”¨

ä½¿ç”¨ç›¸åŒçš„åŸç†ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°é€šè¿‡ NFT æˆæƒçš„ç™»å½•ã€‚ ä¾‹å¦‚ï¼Œé€šå¸¸æ‚¨å¯èƒ½å¸Œæœ›åªå…è®¸äººä»¬åœ¨æ‹¥æœ‰è‡³å°‘ 1 ä¸ªï¼ˆæˆ–æ›´å¤šï¼‰é›†åˆä¸­çš„ NFT æ—¶ç™»å½•ã€‚

æ‚¨å¯ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½æ¥å®ç°é€šè¿‡ NFT è®¤è¯ç¤¾åŒºå’Œç½‘ç«™ã€‚

### Server

```javascript
///////////////////////////////////////////////////////////////////////////////////////////
//
//  When a user logs in, take a snapshot of an ERC20 token balance and store it in cookie
//
///////////////////////////////////////////////////////////////////////////////////////////
const Privateparty = require('privateparty')
const party = new Privateparty()
party.add("mfer", {
  contracts: {
    sartoshi: {
      address: "0xf7d134224a66c6a4ddeb7dee714a280b99044805",
      rpc: "https://eth-mainnet.alchemyapi.io/v2/NgVL3BEuBntBU4cbzjh3FxBIDO8dZM4y",
      abi: party.abi.erc721
    }
  },
  authorize: async (req, account, contracts) => {
    let balance = await contracts.sartoshi.methods.balanceOf(account).call()
    if (balance > 0) return { balance: balance }
    else throw new Error("must own at least one 'end of sartoshi'")
  }
})
party.app.get("/", party.protect("mfer"), (req, res) => {
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

### Client

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<h1>Some exclusive content!</h1>
<div>This page is protected by Privateparty "mfers" role</div>
</body>
</html>
```

## ç”¨ NFT ç™»å½•

![loginwithnft.gif](loginwithnft.gif)

æœ‰æ—¶ä½ å¯èƒ½æƒ³ç›´æ¥â€œä½¿ç”¨ NFT ç™»å½•â€ï¼Œå¹¶ç›´æ¥åœ¨ cookie ä¸­è®¾ç½® NFT å›¾åƒçš„URLã€‚

è¿™æ ·ï¼Œä¸€æ—¦ç”¨æˆ·ç™»å½•åº”ç”¨ç¨‹åºï¼Œåº”ç”¨ç¨‹åºå°±å¯ä»¥åœ¨æ•´ä¸ªåº”ç”¨ç¨‹åºä¼šè¯ä¸­ä½¿ç”¨è¯¥NFTçš„ç›¸å…³æ•°æ®ï¼ˆä¾‹å¦‚ç¼–å·ã€å›¾åƒ...ï¼‰ã€‚

ä½†æ˜¯ï¼ŒPrivateparty æœåŠ¡å™¨å¦‚ä½•çŸ¥é“æ‚¨æƒ³ä½¿ç”¨å“ªä¸ªç¡®åˆ‡çš„ NFT ç™»å½•ï¼Ÿ

éœ€è¦å‘æœåŠ¡å™¨å‘é€é¢å¤–çš„æ•°æ®ï¼Œå¯ä»¥åœ¨è°ƒç”¨ `connect()` æ–¹æ³•æ—¶ç®€å•åœ°ä¼ é€’å…¶ä»–å±æ€§ï¼š

### Client

è®©æˆ‘ä»¬é¦–å…ˆåˆ›å»ºä¸€ä¸ªä¸æœåŠ¡å™¨é€šä¿¡çš„æ–‡ä»¶ï¼š `index.html` 

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
img { width: 50px; height: 50px; flex-shrink: 0; margin-right: 10px; border-radius: 50px; }
nav { display: flex; align-items: center; }
</style>
</head>
<body>
<nav>
  <img class='hidden'>
  <input type='text' placeholder='collection address' id='collection'>
  <input type='text' placeholder='tokenId' id='id'>
  <button></button>
</nav>
<pre class='session'></pre>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("user")
  console.log("session", session)
  // if logged in (session exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
  if (session && session.auth && session.auth.image) {
    document.querySelector("img").src = session.auth.image 
    document.querySelector("img").classList.remove("hidden")
  } else {
    document.querySelector("img").classList.add("hidden")
  }
}
document.querySelector("button").addEventListener("click", async (e) => {
  let session = await party.session("user")
  if (session) {
    await party.disconnect("user")      // if logged in, log out
  } else {
    // Pass additional payload
    // These will be accessible as req.body.payload
    let connection = await party.connect("user", {
      collection: document.querySelector("#collection").value,
      tokenId: document.querySelector("#id").value
    })
    console.log("connection", connection)
  }
  await render()
})
render()
</script>
</body>
</html>
```

è¯·æ³¨æ„ç¬¬ä¸€è¡Œ `await party.connect("user")` , å®ƒä¼ é€’äº†ä¸€ä¸ªå…·æœ‰ `collection` å’Œ `tokenId` å±æ€§çš„å¯¹è±¡ï¼š

```javascript
let connection = await party.connect("user", {
  collection: document.querySelector("#collection").value,
  tokenId: document.querySelector("#id").value
})
```

ä¾‹å¦‚ï¼Œè¾“å…¥å€¼å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼š

```json
{
  collection: "0x6866ed9a183f491024692971a8f78b048fb6b89b",
  tokenId: "55005454344647406361450320675654878134478584534017520891306338141495783002503"
}
```

è¯¥å¯¹è±¡å°†ä½œä¸º `req.body.payload` ä¼ é€’ç»™ OpenAvatar-SDK æœåŠ¡å™¨ `authorize()` ç¨‹åºï¼Œä¸‹é¢å¯¹æ­¤è¿›è¡Œè§£é‡Šï¼š

### Server

é¦–å…ˆå®‰è£…ä¾èµ–åº“:

```
npm install privateparty @alch/alchemy-web3
```

ç„¶åï¼Œåˆ›å»ºä¸€ä¸ªåä¸º `index.js` çš„æ–‡ä»¶å¹¶ç¼–å†™åˆå§‹åŒ–é€»è¾‘ï¼š

```javascript
///////////////////////////////////////////////////////////////////////////////////////////
//
//  When a user logs in, take a snapshot of an ERC20 token balance and store it in cookie
//
///////////////////////////////////////////////////////////////////////////////////////////
const fetch = require('cross-fetch')
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
const web3 = createAlchemyWeb3(<YOUR JSON-RPC ENDPOINT URL>)
const party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    //  req.body.payload := {
    //    collection: "0x6866ed9a183f491024692971a8f78b048fb6b89b",
    //    tokenId: "55005454344647406361450320675654878134478584534017520891306338141495783002503"
    //  }
    console.log("req.body", req.body)
    console.log("account", account)

    // Query the blockchain to get the ERC721 tokenURI
    let tokenURI = await party.contract(web3, party.abi.erc721, req.body.payload.collection).tokenURI(req.body.payload.tokenId).call()
    // Get the image URL and turn it into IPFS gateway URL.
    let image = await fetch("https://ipfs.io/ipfs/" + tokenURI.replace("ipfs://", "")).then(r => r.json()).then(r => r.image)
    return {
      tokenURI,
      image: "https://ipfs.io/ipfs/" + image.replace("ipfs://", "")
    }
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

ç°åœ¨è¿è¡Œå‘½ä»¤ `node index` å¹¶æ‰“å¼€æµè§ˆå™¨é“¾æ¥ http://localhost:3000

æ‚¨å°†çœ‹åˆ°ä¸€ä¸ªç™»å½•ç•Œé¢ï¼Œå¯ä»¥åœ¨å…¶ä¸­è¾“å…¥ NFT åˆçº¦åœ°å€å’Œ tokenIdã€‚

åªæœ‰å½“ä½ çš„é’±åŒ…æ‹¥æœ‰ NFT æ—¶ï¼Œæ‰èƒ½ç™»å½•ã€‚


## å¤šè§’è‰²

Sometimes you may want to support multiple roles for a single account.

For example, Alice may be a "user" in a web app, but she may also be the "admin" who can have an admin interface. Only those with an "admin" role can access the admin interface, while the rest of the users can only have the "user" role and access the user interface.

Let's try building a minimal app that does that. We will build:

1. Privateparty server
2. User interface
3. Admin inteface

æœ‰æ—¶ä½ å¯èƒ½å¸Œæœ›ä¸ºå•ä¸ªå¸æˆ·æ”¯æŒå¤šè§’è‰²ã€‚

ä¾‹å¦‚ï¼ŒAlice å¯èƒ½æ˜¯ Web3 åº”ç”¨ä¸­çš„â€œuserâ€è§’è‰²ï¼Œä½†å¥¹ä¹Ÿå¯ä»¥æ‹¥æœ‰ç®¡ç†ç•Œé¢çš„â€œadminâ€è§’è‰²ã€‚ åªæœ‰æ‹¥æœ‰â€œadminâ€ç®¡ç†å‘˜è§’è‰²çš„ç”¨æˆ·æ‰èƒ½è®¿é—®ç®¡ç†ç•Œé¢ï¼Œè€Œå…¶ä½™æ‹¥æœ‰â€œuserâ€è§’è‰²çš„ç”¨æˆ·åªèƒ½å¹¶è®¿é—®æ™®é€šç”¨æˆ·ç•Œé¢ã€‚

è®©æˆ‘ä»¬æ­å»ºä¸€ä¸ªæœ€å°åº”ç”¨ç¤ºä¾‹ã€‚ æˆ‘ä»¬å°†å»ºç«‹ï¼š

1. OpenAvatar-SDK æœåŠ¡å™¨
2. ç”¨æˆ·é¡µé¢
3. ç®¡ç†å‘˜é¡µé¢

### Server

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty()

// Add a "user" role => will automatically create the default the following endpoints:
//
//  session: "/privateparty/admin/session",
//  connect: "/privateparty/admin/connect",
//  disconnect: "/privateparty/admin/disconnect",
//
party.add("user")

// Add an "admin" role with custom endpoints:
party.add("admin", {
  session: "/privateparty/admin/session",
  connect: "/privateparty/admin/connect",
  disconnect: "/privateparty/admin/disconnect",
  authorize: (req, account) => {
    // Currently anyone can login as admin, but you can add a logic to only allow certain addresses to login
    return { admin: true }
  }
})

// "user" interface => will display the index.html file
party.app.get("/", party.auth("user"), (req, res) => {
  res.sendFile(process.cwd() + "/index.html")
})

// "admin" interface => will display the admin.html file
party.app.get("/admin", party.auth("admin"), (req, res) => {
  res.sendFile(process.cwd() + "/admin.html")
})
party.app.listen(3000)
```

### ç”¨æˆ·é¡µé¢

é€šè¿‡ http://localhost:3000 è®¿é—®ç”¨æˆ·ç•Œé¢ï¼ˆè·¯ç”±â€œ/â€ï¼‰ï¼Œä»»ä½•å¸æˆ·éƒ½å¯ä»¥ç™»å½•ã€‚

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <h1>User page</h1>
  <button></button>
  <pre class='session'></pre>
  <a href="/admin">go to admin dashboard</a>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  let session = await party.session("user")
  try {
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```

### ç®¡ç†å‘˜é¡µé¢

é€šè¿‡ http://localhost:3000/admin è®¿é—®ç®¡ç†ç•Œé¢ï¼ˆè·¯ç”±â€œ/adminâ€ï¼‰ã€‚ æ‚¨å¯ä»¥ç”¨â€œç®¡ç†å‘˜â€èº«ä»½ç™»å½•ã€‚ ä¸Šé¢çš„OpenAvatar-SDK æœåŠ¡å™¨ä»£ç å…è®¸ä»»ä½•äººä»¥ç®¡ç†å‘˜èº«ä»½ç™»å½•ï¼Œä½†æ‚¨å¯ä»¥æ›´æ–° `authorize()` éƒ¨åˆ†ä»…æˆæƒç™½åå•ï¼ˆåå•ä¸­çš„åœ°å€å¯ä»¥ç™»å½•ï¼‰ä»¥ç®¡ç†å‘˜èº«ä»½ç™»å½•ã€‚

```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <h1>Admin page</h1>
  <button></button>
  <pre class='session'></pre>
  <a href="/">go to user dashboard</a>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("admin")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  let session = await party.session("admin")
  try {
    if (session) {
      await party.disconnect("admin")      // if logged in, log out
    } else {
      await party.connect("admin")         // if logged out, log in
    }
    await render()
  } catch (e) {
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```

## Cross origin login

Sometimes your frontend code may be hosted on a different domain than the backend.

In this case you can use the built-in CORS support to allow ONLY the domain you specify to authenticate using your privateparty server.

Let's set up:

1. A privateparty server at port 3007
2. A frontend website running at port 8080

The frontend website at 8080 will try to authenticate against the privateparty server at http://localhost:3007

### Server

Save the following code as `index.js`:

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty({
  cors: {
    credentials: true,
    origin: ["http://localhost:8080"] // Allow port 8080 to access the server cross origin
  }
})
party.add("user")
party.app.listen(3000)
```

### Client

Save the following code as `index.html`:


```html
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
<style>
.hidden { display: none; }
</style>
</head>
<body>
<nav>
  <button></button>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty({
  host: "http://localhost:3000"
})
const render = async () => {
  let session = await party.session("user")
  // if logged in (session.user exists), it's a logout button. if logged out, it's a login button.
  document.querySelector("button").innerHTML = (session ? "logout" : "login")
  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
document.querySelector("button").addEventListener("click", async (e) => {
  let session = await party.session("user")
  try {
    if (session) {
      await party.disconnect("user")      // if logged in, log out
    } else {
      await party.connect("user")         // if logged out, log in
    }
    await render()
  } catch (e) {
    document.querySelector(".session").innerHTML = e.message
  }
})
render()
</script>
</body>
</html>
```

The only differnt part here is the initialization step:

```javascript
const party = new Privateparty({
  host: "http://localhost:3000"
})
```

By default, the partyconnect.js client makes requests to the same domain. But you can customize the endpoint by setting the `host` attribute when initializing a Privateparty client.

### Run

First start the privateparty server:

```
node index
```

Now let's launch the `index.html` at port 8080 using:

```
npx http-server
```

Now open the browser at http://localhost:8080 and it should work as intended.

## Cross platform login

Privateparty is powered by [JWT](https://en.wikipedia.org/wiki/JSON_Web_Token).

This means you can use the same generated token **both inside and outside the browser**. "outside the browser" can be anywhere, including:

- mobile app
- server
- serverless function (AWS lambda, vercel, netlify, etc.)
- IoT device
- and so on..

Let's check out how to authenticate and authorize using a node.js app.

### Server

For the sake of simplicity, we will just create a privateparty server that lets anyone log in (therefore there is no `authorize()` function:

```javascript
///////////////////////////////////////////////////////////////////////////////////////////
//
//  When a user logs in, take a snapshot of an ERC20 token balance and store it in cookie
//
///////////////////////////////////////////////////////////////////////////////////////////
const Privateparty = require('privateparty')
const party = new Privateparty()
party.add("user")
party.app.get("/api", party.protect("user", { json: { error: "not logged in" } }), (req, res) => {
  res.json({ status: "Logged in!" })
})
party.app.listen(3000)
```

If you want to t


### Client

For this we will use a node.js client named `partypass`, and `cross-fetch` (to make fetch requests).

```
npm install partypass
```

Now create a file named `client.js`:

```javascript
const Partypass = require('partypass')
const fetch = require('cross-fetch')
const run = async () => {
  const pass = new Partypass({
    host: "http://localhost:3000",
    key: "cd76c32ffeae94b725b40b1f58ffc793d5b0e96596f8d067f29d385894f16424" // replace with your private key
  });
  const session = await pass.create("user"); // The session object will contain { jwt, account, ... }

  // Now let's make a request with the jwt
  let response = await fetch("http://localhost:3000/api", {
    headers: {
      authorization: `token ${session.jwt}`
    }
  }).then((r) => {
    return r.json()
  })
  console.log(response)
}
run()   // run it!
```

Run it with `node client`.

1. The `client.js` will make a request to the privateparty server at port 3000 to get a session
2. Then it will use the `session.jwt` in the authorization header to make an authenticated request to the `/api` endpoint, which will succeed.

It will print:

```
{ status: 'Logged in!' }
```

Now, just to make sure that it fails when there's no token, let's try making the same request, but without the authorization header:

```javascript
const Partypass = require('partypass')
const fetch = require('cross-fetch')
const run = async () => {
  let response = await fetch("http://localhost:3000/api").then((r) => {
    return r.json()
  })
  console.log(response)
}
run()   // run it!
```

It will print:

```
{ error: 'not logged in' }
```

## One-liner login/logout

We've looked at ways to authenticate using JavaScript. But there's an even simpler way to get started. All you need to do is send users to a "gate" page.

### Server

Let's first set up a simple Privateparty server by writing a file named `app.js`.

```javascript
const party = new Privateparty()
party.add("user")
party.app.get("/", (req, res) => {
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

When a user goes to the `/` route, it will display the `index.html` page regardless of whether logged in or not. Let's take a look at the `index.html` file:

### Client

The following code does not use any Javascript code to authenticate. Instead, just by adding one line `<a id='account' href='/privateparty/gate/user?callback=/'></a>`, the user can click to open a "gate" page to login or logout, and come back (kind of like opening a facebook login page for "facebook connect" and redirecting back after logging in):

```html
<html>
<head>
<script src="https://unpkg.com/partyconnect@0.0.42/dist/partyconnect.js"></script>
</head>
<body>
<nav>
  <a id='account' href="/privateparty/gate/user?callback=/"></a>
  <pre class='session'></pre>
</nav>
<script>
const party = new Privateparty()
const render = async () => {
  let session = await party.session("user")

  // if logged in, display the account. Otherwise display "login"
  document.querySelector("a").innerHTML = (session ? session.account : "login")

  // print the current session
  document.querySelector(".session").innerHTML = JSON.stringify(session, null, 2)
}
render()
</script>
</body>
</html>
```

Run the server with `node app.js` and go to http://localhost:3000 - you will see:

![gate.gif](gate.gif)

> Pay attention to how the browser URL changes.
> 
> - When the user clicks "login" it goes to /privateparty/gate/user?callback=/
> - Then after logging in, it automatically redirects back to "/" because of the callback
> - Same process for the logout. After logging out, it automatically redirects back to "/"

Let's go through the HTML to see what's going on.

1. First of all, the `render()` method checks the `user` session and displays the account if logged in, otherwise "login". This part we are familiar with.
2. Next, notice the `<a>` tag. It has an `href` attribute of `/privateparty/gate/user?callback=/`. Let's break this down.
    - The `/privateparty/gate/user` is the default route for the built-in "gate" page, which lets the user login (if logged out) or log out (if logged in).
      - This route is automatically generated from the role name. For example, to send a user to an `admin` role login page, the link would be `/privateparty/gate/admin`.
    - The `?callback=/` part tells the gate page which URL to redirect the user to after logging in (or logging out).
      - In this case, we want the login page to automatically send the user back to the `/` route, so the `callback` is `/`.

### Mobile support

To automatically support mobile wallets for the built-in gate page, you need to initialize the Privateparty with a custom `gate` config with the `walletconnect` attribute (the Infura ID):


```javascript
const party = new Privateparty({
  gate: {
    walletconnect: "667750972a89441ea5d276ed16d7eef0"
  }
})
party.add("user")
party.app.get("/", (req, res) => {
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```


## More examples

Check out the [demo folder](https://github.com/privatepart/privateparty/tree/main/demo) on GitHub for more examples.

## React component

Using react? Try the react component: [Partybutton](https://partybutton.papercorp.org/)

![partybutton.png](partybutton.png)

---

# Install

You can implement a Privateparty web app with 2 libraries (server-side and client-side) that talk to each other:

1. `privateparty`: The server-side module
2. `partyconnect`: The browser client for privateparty => automatically uses the browser wallets and sets the cookies after logging in.
3. `partypass`: The node.js client for privateparty => stateless client for making a request to a privateparty server and getting back a new session in a JWT.

## Server

To install:

```
npm install privateparty
```

Then, use the module in your app like this:

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty()
```

## Browser client

### Load from CDN

Include in your frontend web app:

```html
<script src="https://unpkg.com/partyconnect/dist/partyconnect.js"></script>
```

### Import

```
npm install partyconnect
```

Then initialize with:

```javascript
// CJS
const Privateparty = require('partyconnect')
const party = new Privateparty(config)
```

or

```javascript
// ESM
import Privateparty from 'partyconnect'
const party = new Privateparty(config)
```

> If the code works fine but you're having trouble when you're trying to package for production with webpack, it's probably because webpack 5 has started excluding node.js core modules (for any library that uses node.js core modules). See this article to learn how to resolve this issue: https://www.alchemy.com/blog/how-to-polyfill-node-core-modules-in-webpack-5

## Node.js client

### Import

```
npm install partypass
```

Then initialize with:

```javascript
// CJS
const Partypass = require('partypass')
const pass = new Partypass(config)
```

or

```javascript
// ESM
import Partypass from 'partypass'
const pass = new Partypass(config)
```

### Load from CDN

Although partypass is a node.js client, you can use it in the web in certain cases.

For example, a server may use `pass.build()` to create a pass creation request, and send it to the user's browser, where the user makes the request using `pass.request()`. In this case you can also use the CDN JS:

Include in your frontend web app:

```html
<script src="https://unpkg.com/partypass/dist/partypass.js"></script>
```

---

# API

## Server

For the backend, you need to use the package `privateparty`. Simply instantiate a new `Privateparty` instance and it should give you everything you need to build a wallet protected web app backend.

### constructor

#### syntax

```javascript
const party = new Privateparty(config)
```

#### parameters

- `config`: privateparty server configuration
  - `secret`: **(optional)** a string used for signing cookies
    - See https://github.com/expressjs/cookie-parser#cookieparsersecret-options
    - If not specified, it will autogenerate a secret everytime the server restarts using [uuid](https://github.com/uuidjs/uuid).
  - `cors`: **(optional)** If you want to support CORS (cross origin requests) pass this attribute.
    - See https://github.com/expressjs/cors#configuration-options
  - `app`: **(optional)** Inject an existing instantiated express.js app instance
  - `express`: **(optional)** Inject an existin express module
  - `gate`: **(optional)** The built-in gate page config
    - `walletconnect`: The Walletconnect Infura ID, to support mobile wallets.
    - `fresh`: when using the default login page, whether the login should ask the user to (re-)connect a wallet from the wallet list, or to use the previously connected wallet if still connected
      - if `true`, the login attempt always displays all the wallets from the list and lets the user select one
      - if `false`, tries to immediately use a previously selected wallet to skip the wallet selection step (This is the default)

#### return value

- `party`: The initialized privateparty instance, which contains the following attributes:
  - `app`: an "app" instance created internally by calling `const app = express()`
  - `express`: the express module
  - `auth`: authentication & authorization function
  - `protect`: authentication & authorization function + error handling
  - `add`: a function to add authorization groups

> the `auth` method only tells you if the authorization results in a legitimate session or not, whereas the `protect` method is used to do what `auth` does but also automatically redirect to a logged out page or display a logged out page.

#### examples

##### 1. minimal server

```javascript
const party = new Privateparty()
```

##### 2. server with a fixed signing secret

```javascript
const party = new Privateparty({
  secret: "top secret"
})
```

##### 3. cross origin login support

In the following example, we have a privateparty server running at port 3001, and it allows requests from not just the port 3001 but also 3000, since we specified the origin http://localhost:3000

```javascript
const party = new Privateparty({
  cors: {
    credentials: true,
    origin: ["http://localhost:3000"]
  }
})
party.listen(3001)
```

##### 4. cross origin login with dynamic origin parsing

Using the dynamic origin configuration option from the CORS module (https://github.com/expressjs/cors#configuring-cors-w-dynamic-origin), you can dynamically parse request origins and authorize:

```javascript
const party = new Privateparty({
  cors: {
    credentials: true,
    origin: (origin, callback) => {
      // allow ALL localhost connections
      if (/localhost:[0-9]+/i.test(origin)) {
        callback(null, true)
      } else {
        callback(new Error())
      }
    }
  }
})
party.listen(3001)
```

##### 5. integrate with an existing express.js app

```javascript
const express = require('express')
const app = express()
const port = 3000

// Inject express app to Privateparty!
const party = new Privateparty({
  app: app,
})
// Define the authorization logic
party.add("user", {
  authorize: (req, account) => {
    // only allow 0xf7d134224a66c6a4ddeb7dee714a280b99044805 to log in
    if (account === "0xf7d134224a66c6a4ddeb7dee714a280b99044805") {
      return { authorized: true }
    } else {
      throw new Error("not allowed")
    }
  }
})
// Protect the app with the authorization role!
app.get('/', party.protect("user"), (req, res) => {
  res.send('Hello World!')
})
app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})
```

### add()

Add a group to the party

#### syntax

```javascript
await party.add(name, config)
```

#### parameters

- `name`: group name (must be unique per group)
- `config`: configuration options for each group
  - `session`: (optional) The GET path to query the current session for this engine. (default: `/privateparty/session/${name}`)
  - `connect`: (optional) The POST path to create a session for this engine (default: `/privateparty/connect/${name}`)
  - `disconnect`: (optional) The POST path to destroy a session for this engine (default: `/privateparty/disconnect/${name}`)
  - `gate`: (optional) The gate page route for this engine (The "login/logout" page) (default: `privateparty/gate/${name}`)
  - `authorize`: a function that takes two or more arguments `req` (The incoming request object passed from express), `account` (The authenticated wallet address), and optionally `contracts` (only when you specify another attribute `contract`, explained below). 
    - To disallow a session based on the request, simply throw an error in the function.
    - To authorize the session, don't throw a function. Additionally, the return value of this function will be automatically set as the `auth` attribute of the session
  - `expire`: (optional) The session duration (how many seconds until a session expires). The default is `1000 * 60 * 60 * 24 * 30` (30 days).
  - `tokens`: (optional) an array of access tokens to allow
  - `contracts`: (optional) a declarative object for defining one or more contracts, which will be initialized and injected in to the `authoirze()` handler


#### return value

none

#### example

```javascript
const Privateparty = require('privateparty')
const party = new Privateparty()
party.add("user", {

  session: "/privateparty/session/user",            // custom path for the session route
  connect: "/privateparty/connect/user",            // custom path for the connect route 
  disconnect: "/privateparty/disconnect/user",      // custom path for the disconnect route
  gate: "/privateparty/gate/user",                  // custom path for the gate page route

  // Define as many contracts as you want, using <name>: <description object>
  contracts: {
    sartoshi: {
      address: "0xf7d134224a66c6a4ddeb7dee714a280b99044805",
      rpc: process.env.RPC,
      abi: party.abi.erc721
    }
  },

  authorize: async (req, account, contracts) => {

    // The "request" is the full HTTP request object (express.js)
    // The "account" is the account derived from the incoming signature
    // The "contracts" is an object made up of instantiated Web3.js contract objects, determined by the "contracts" attribute above

    let balance = await contracts.sartoshi.methods.balanceOf(account).call()
    console.log("balance", balance)
    if (balance > 0) {
      return { balance: balance }
    } else {
      throw new Error("must own at least one 'end of sartoshi'")
    }
  },

  expire: 1000 * 60 * 60 * 24,   // expire after 1 day

  // access tokens for API access
  tokens: [
    "01127c36-32fa-4c85-b6da-f720796fe679",
    "35161a5c-60f0-4809-8b49-1a662247f5b3"
  ]
  

})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

### auth()

The authorization middleware you can add to any route.

To add authorization logic to any route, you need to:

1. First define an authrorization group and its behavior through the `add()` method
2. Then make use of the group by calling `party.auth(name)`

#### syntax

```javascript
party.app.get(route1, party.auth(name), (req, res) => {
  ...
})
party.app.post(route2, party.auth(name), (req, res) => {
  ...
})
```

#### parameters

- `name`: The authorization group name to use for the route handler


#### examples

##### 1. Default authentication

The following example simply authenticates a user's account based on the wallet signature.

```javascript
const party = new Privateparty()
party.add("user")
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
```

1. The `party.add("user"` line will create a group named "user", which automatically creates the following routes:
    - `POST /privateparty/connect`
    - `POST /privateparty/disconnect`
    - `GET /privateparty/session`
2. Then the express app instance (`party.app`) handles the `GET /` request. But before that, it goes through the `party.auth("user")` middleware.
3. Since the `party.add("user")` did not specify any authorization logic, it will just allow all requests.
4. Therefore, when a user first visits the `/` route, the `req.session` will be null but...
3. After authenticating from the frontend, the `req.session` will contain `{ "user": { "account": <user address> } }`

##### 2. Authorization

By default, Privateparty logs everyone in. But often you will want to only allow certain people in.

You can achieve this with an `authorize(req, account)` function:

```javascript
const Privateparty = require('privateparty')
const allowed = [
  "0xab3b229eb4bcff881275e7ea2f0fd24eeac8c83a",
  "0x1ad91ee08f21be3de0ba2ba6918e714da6b45836",
  "0x829bd824b016326a401d083b33d092293333a830"
]
const party = new Privateparty()
party.add("user", {
  session: "/privateparty/session",
  connect: "/privateparty/connect",
  disconnect: "/privateparty/disconnect",
  authorize: async (req, account) => {
    if (!allowed.includes(account) {
      throw new Error("not allowed")
    }
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

Note that we are:

1. adding a group named `"user"`
2. and then using the group in the `party.app.get("/", party.auth("user", (req, res) => { . . . })` handler.


##### 3. Multiple auth engines

Sometimes you may want to serve different content based on different roles. You can create roles with engines.

In the following code, we are using 2 engines:

1. user: normal user login flow. sign everyone in
2. admin: admin user login flow. check if the account is included in the ADMIN array, and if not, throw an error

```javascript
const Privateparty = require('privateparty')
const ADMINS = ["0x502b2fe7cc3488fcff2e16158615af87b4ab5c41"]
const party = new Privateparty()
party.add("user", {
  session: "/privateparty/session",
  connect: "/privateparty/connect",
  disconnect: "/privateparty/disconnect",
})
party.add("admin", {
  session: "/privateparty/admin/session",
  connect: "/privateparty/admin/connect",
  disconnect: "/privateparty/admin/disconnect",
  authorize: async (req, account) => {
    if (ADMINS.includes(account)) {
      return { admin: true }
    } else {
      throw new Error("not an admin")
    } 
  }
})
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.get("/admin", party.auth("admin"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

Note that we have two `GET` route handlers here:

1. `GET /`: The normal route for normal users. Because we're using `auth("user")`, it will use the `user` group.
2. `GET /admin`: The page where the admins can login. Because we're using `auth("admin")`, it will use the `admin` group.


### protect()

Like `auth()`, but automatically redirects to the built-in login page if not authorized.

> The `auth()` method returns a `null` value for `req.session` when not authorized, and that's all. The `protect()` method actually redirects to the login page.

To add the protection logic to any route, you need to:

1. First define an authrorization group and its behavior through the `add()` method
2. Then make use of the group by calling `party.protect(name)`

#### syntax


```javascript
party.protect(name, options)
```

Example usage:

```javascript
party.app.get(route1, party.protect(name), (req, res) => {
  ...
})
party.app.post(route2, party.protect(name), (req, res) => {
  ...
})
```



#### parameters

- `name`: The authorization group name to use for the route
- `options`: additional information about the protection
  - `redirect`: The web route to redirect to when logged out. For example you can set up an additional route that displays a web page when logged out.
  - `render`: The HTML file path to render when logged out.
  - `json`: The JSON object to return when logged out, and the request was made as an API request (not a website)
  - `walletconnect`: The Walletconnect Infura ID, to support mobile wallets.
  - `fresh`: when using the default login page, whether the login should ask the user to (re-)connect a wallet from the wallet list, or to use the previously connected wallet if still connected
    - if `true`, the login attempt always displays all the wallets from the list and lets the user select one
    - if `false`, tries to immediately use a previously selected wallet to skip the wallet selection step (This is the default)

The difference between the `redirect` and the `render` option is that, the `redirect` sends the user to a different designated route (for example a `/login` route), whereas `render` DOES NOT take the user to any other URL but just displays the supplied HTML.

#### examples

All examples in this section are the same as the `auth()` examples, except that you're using `party.protect()` instead of `party.auth()`.

##### 1. Default protection

The following example simply authenticates a user's account based on the wallet signature.

```javascript
const party = new Privateparty()
party.add("user")
party.app.get("/", party.protect("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
```

1. The `party.add("user"` line will create a group named "user", which automatically creates the following routes:
    - `POST /privateparty/connect`
    - `POST /privateparty/disconnect`
    - `GET /privateparty/session`
2. Then the express app instance (`party.app`) handles the `GET /` request. But before that, it goes through the `party.protect("user")` middleware.
3. Since the `party.add("user")` did not specify any authorization logic, it will just allow all requests.
4. Therefore, when a user first visits the `/` route, the `req.session` will be null but...
3. After authenticating from the frontend, the `req.session` will contain `{ "user": { "account": <user address> } }`

Unlike the `auth()` example, when you first visit the `/` route, Privateparty will automatically redirect you to its built-in login page.

##### 2. Authorization

By default, Privateparty logs everyone in. But often you will want to only allow certain people in.

You can achieve this with an `authorize(req, account)` function:

```javascript
const Privateparty = require('privateparty')
const allowed = [
  "0xab3b229eb4bcff881275e7ea2f0fd24eeac8c83a",
  "0x1ad91ee08f21be3de0ba2ba6918e714da6b45836",
  "0x829bd824b016326a401d083b33d092293333a830"
]
const party = new Privateparty()
party.add("user", {
  session: "/privateparty/session",
  connect: "/privateparty/connect",
  disconnect: "/privateparty/disconnect",
  authorize: async (req, account) => {
    if (!allowed.includes(account) {
      throw new Error("not allowed")
    }
  }
})
party.app.get("/", party.protect("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

Note that we are:

1. adding a group named `"user"`
2. and then using the group in the `party.app.get("/", party.protect("user", (req, res) => { . . . })` handler.


##### 3. Multiple protection engines

Sometimes you may want to serve different content based on different roles. You can create roles with engines.

In the following code, we are using 2 engines:

1. user: normal user login flow. sign everyone in
2. admin: admin user login flow. check if the account is included in the ADMIN array, and if not, throw an error

```javascript
const Privateparty = require('privateparty')
const ADMINS = ["0x502b2fe7cc3488fcff2e16158615af87b4ab5c41"]
const party = new Privateparty()
party.add("user", {
  session: "/privateparty/session",
    connect: "/privateparty/connect",
    disconnect: "/privateparty/disconnect",
  },
})
party.add("admin", {
  session: "/privateparty/admin/session",
  connect: "/privateparty/admin/connect",
  disconnect: "/privateparty/admin/disconnect",
  authorize: async (req, account) => {
    if (ADMINS.includes(account)) {
      return { admin: true }
    } else {
      throw new Error("not an admin")
    } 
  }
})
party.app.get("/", party.protect("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.get("/admin", party.protect("admin"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
party.app.listen(3000)
```

Note that we have two `GET` route handlers here:

1. `GET /`: The normal route for normal users. Because we're using `party.protect("user")`, it will use the `user` group.
2. `GET /admin`: The page where the admins can login. Because we're using `party.protect("admin")`, it will use the `admin` group.


##### 4. Custom logged out handling

By default the `protect()` modifier automatically sends the users to the built-in login page where the user can log in for that role.

But if you want a custom handler, you can do something like this:


```javascript
const Privateparty = require('privateparty')
const allowed = [
  "0xab3b229eb4bcff881275e7ea2f0fd24eeac8c83a",
  "0x1ad91ee08f21be3de0ba2ba6918e714da6b45836",
  "0x829bd824b016326a401d083b33d092293333a830"
]
const party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    if (!allowed.includes(account) {
      throw new Error("not allowed")
    }
  }
})
party.app.get("/login", (req, res) => {
  res.sendFile(__dirname + "/login.html")
})
party.app.get("/", party.protect("user", { redirect: "/login" } ), (req, res) => {
  console.log("session", req.session)
  res.sendFile(__dirname + "/index.html")
})
party.app.listen(3000)
```

Or if you DO NOT want to send the user to a new route but just display the error, you can use the `render` option:


```javascript
const Privateparty = require('privateparty')
const allowed = [
  "0xab3b229eb4bcff881275e7ea2f0fd24eeac8c83a",
  "0x1ad91ee08f21be3de0ba2ba6918e714da6b45836",
  "0x829bd824b016326a401d083b33d092293333a830"
]
const party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    if (!allowed.includes(account) {
      throw new Error("not allowed")
    }
  }
})
party.app.get("/", party.protect("user", { render: __dirname + "/login.html" } ), (req, res) => {
  console.log("session", req.session)
  res.sendFile(__dirname + "/index.html")
})
party.app.listen(3000)
```

##### 5. Token authentication

In addition to using the authenticted user's credentials for authorizing, you can use access token based authorization.

Here's an example:


```javascript
const party = new Privateparty()
party.add("user", {
  tokens: [
    "01127c36-32fa-4c85-b6da-f720796fe679",
    "35161a5c-60f0-4809-8b49-1a662247f5b3"
  ]
})
// Our JSON API endpoint
party.app.get("/api", party.protect("user"), (req, res) => {
  res.json({
    people: ["alice", "bob", "carol"]
  })
})
party.app.get("/", party.protect("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
```


This will:

1. Allow ALL authenticated user to log in in the browser using cookies (since there is no `authorize()` callback to restrict access
2. Allow only those who have access to the access tokens `01127c36-32fa-4c85-b6da-f720796fe679` and `35161a5c-60f0-4809-8b49-1a662247f5b3` to make request to the app.

To make an access token authenticated request, you need to set the HTTP request header's `Authorization` field as `token <ACCESS_TOKEN>`. Example:

```javascript
fetch("https://protectedendpoint.com/api", {
  headers: {
    "Authorization": "token 01127c36-32fa-4c85-b6da-f720796fe679"
  }
}).then((r) => {
  return r.json()
}).then((r) => {
  console.log(r)
})
```

##### 6. Mobile wallet support

The following example simply authenticates a user's account based on the wallet signature.

```javascript
const party = new Privateparty()
party.add("user")

// Use the walletconnect Inufra ID to support mobile wallets on the default login page
party.app.get("/", party.protect("user", { walletconnect: "667750972a89441ea5d276ed16d7eef0" }), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})
```


### contract()

Creates and returns a web3 contract methods object, which can be chained to call web3 methods.

#### syntax

```javascript
const methods = party.contract(web3, abi, contract_address)
```

#### parameters

- `web3`: an initialized web3 object
- `abi`: an ABI array
- `contract_address`: the contract address

#### examples

##### 1. Token balance contract calls

To authorize users based on the blockchain state associated with their authenticated wallet accounts, you will need to query the blockchain.

In this case you will need to instantiate a web3 object and use the built-in `contract()` convenience method to call web3 contract methods

```javascript
// Example. Use your own RPC URL
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
// Use your own JSON-RPC ENDPOINT instead of the URL below!
const web3 = createAlchemyWeb3("https://eth-mainnet.alchemyapi.io/v2/YAB7qBnOb0pceNn29u1v_PATpqKUN623")
let party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    const UNI = "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    const abi = [{
      "constant": true,
      "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ],
      "name": "balanceOf",
      "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }], UNI)
    const balance = await party.contract(web3, abi, UNI).balanceOf(account)
    if (balance >= 100) {
      return { balance } 
    } else {
      throw new Error("you need to own at least 100 $UNI)
    }
  }
})
```

Or equivalently, you can use the built-in `party.abi.erc721` instead of hardcoding the `const abi` part, like this:

```javascript
// Example. Use your own RPC URL
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
// Use your own JSON-RPC ENDPOINT instead of the URL below!
const web3 = createAlchemyWeb3("https://eth-mainnet.alchemyapi.io/v2/YAB7qBnOb0pceNn29u1v_PATpqKUN623")
let party = new Privateparty()
party.add("user", {
  authorize: async (req, account) => {
    const UNI = "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
    const balance = await party.contract(web3, party.abi.erc721, UNI).balanceOf(account)
    if (balance >= 100) {
      return { balance } 
    } else {
      throw new Error("you need to own at least 100 $UNI)
    }
  }
})
```

##### 2. Admin login

Sometimes you may want to build an adming interface that ONLY allows the owner of the contract to login.

Privateparty includes an abi interface for [ownable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol) in addition to erc20 and erc721 ABIs, so you can take advantage of this as well:

```javascript
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
const web3 = createAlchemyWeb3(<YOUR JSON-RPC ENDPOINT URL>)
const party = new Privateparty()
party.add("admin", {
  session: "/privateparty/admin/session",
  connect: "/privateparty/admin/connect",
  disconnect: "/privateparty/admin/disconnect",
  authorize: async (req, account) => {
    const mfers = "0x79fcdef22feed20eddacbb2587640e45491b757f"
    let owner = await party.contract(web3, party.abi.ownable, mfers).owner().call()
    if (owner.toLowerCase() === account) {
      return { admin: true }
    } else {
      throw new Error("not an admin")
    }
  }
})
```

### abi

Built-in convenience module for frequently used ABIs:

#### 1. erc20

```javascript
// use the party.abi.erc20 instead of hardcoding the ABI
const party = new Privateparty()
let balance = await party.contract(web3, party.abi.erc20, UNISWAP_ADDRESS).balanceOf(account).call()
```

#### 2. erc721

```javascript
// use the party.abi.erc721 instead of hardcoding the ABI
const party = new Privateparty()
let tokenURI = await party.contract(web3, party.abi.ownable, MFERS_NFT_ADDRESS).tokenURI(tokenId).call()
```

#### 3. ownable

```javascript
// use the party.abi.ownable instead of hardcoding the ownable ABI
const party = new Privateparty()
let owner = await party.contract(web3, party.abi.ownable, mfers).owner().call()
```

### app

The `app` object internally created with `app = express()`.

You can use the `app` object just like you would with any express app instance.

#### examples

```javascript
const party = new Privateparty()
party.add("members", {
  authorize: async (req, account) => {
    // some membership checking logic
  }
})
party.app.get("/", (req, res) => {
  // public route.
  // no authentication and no authorization
})
party.app.get("/members", party("members"), (req, res) => {
  // members only logic
})
// Don't forget to start the app by listening to a port!
party.app.liten(3000)
```

### express

The expressjs module.



## Browser client

### constructor

#### syntax

```javascript
const party = new Privateparty(config)
```

#### parameters

- `config`: configuration
  - `host`: **(optional)** specify the host in case you wish to make a cross-origin request to a privateparty server hosted on another domoain.
  - `walletconnect`: **(optional)** Specify this field to support mobile and desktop wallets. The `walletconnect` attribute is the [Walletconnect infuraId attribute](https://github.com/Web3Modal/web3modal/blob/master/docs/providers/walletconnect.md?plain=1#L22) (Go to [Infura](https://infura.io/) to sign up and get the Infura project ID).

#### return value

- `party`: An instantiated privateparty client

#### examples

##### 1. basic

```javascript
const party = new Privateparty()
```

##### 2. cross origin connection

Let's say your privateparty server is running at https://myprivatepartyserver.com - You can connect to it using the `host` attribute.

> **NOTE**
>
> You MUST set the CORS support on the server side to make this work http://localhost:56503/#/?id=_3-cross-origin-login-support

```javascript
const party = new Privateparty({
  host: "https://myprivatepartyserver.com"
})
```


##### 3. mobile & desktop wallet support

To support mobile and desktop wallets, we need to use [Walletconnect](https://walletconnect.com/). For this, we need to get a project ID from [Infura](https://infura.io) and set it as the `walletconnect` attribute. Example:

```javascript
const party = new Privateparty({
  walletconnect: "27e484dcd9e3efcfd25a83a78777cdf1"   // USE YOUR OWN INFURA ID!
})
```

---

### connect()

#### syntax

```javascript
let session = await party.connect(name, payload, options)
```

#### parameters

- `name`: the name of a privateparty role. Automatically connects to the endpoints defined on the privateparty backend with the same name.
- `payload`: **(optional)** additional payload that will be passed to the Privateparty server. The Privateparty server will be able to inspect `req.body.payload` in its authorization logic.
- `options`: **(optional)** an object describes how the connection shall be made. includes the following attributes:
  - `fresh`: whether the login should ask the user to (re-)connect a wallet from the wallet list, or to use the previously connected wallet if still connected
    - if `true`, the login attempt always displays all the wallets from the list and lets the user select one
    - if `false`, tries to immediately use a previously selected wallet to skip the wallet selection step (This is the default)

#### return value

- `session`: The authenticated and authorized session object for this connection.
  - `account`: the authenticated account
  - `expiresIn`: how long this session will be valid for since the issued time (`iat`), in seconds. (default: 60 * 60 * 24 * 30, or 30 days)
  - `jwt`: the full JWT string
  - `auth`: **(optional)** additional attributes set by the privateparty server if needed. Only included when you return something from the `authorize()` callback when calling `party.add()`.

The same `session` object will be stored inside the cookie and will be accessible subsequently via `party.session()`

#### examples

##### 1. basic connection

Let's assume the Privateparty backend has added a role named "user":

```javascript
const party = new Privateparty()
party.add("user")
party.app.get("/", party.auth("user"), (req, res) => {
  // public route.
  // no authentication and no authorization
})
party.app.listen(3000)
```

Above code will set up the default endpoints:

- `GET /privateparty/session`
- `POST /privateparty/connect`
- `POST /privateparty/disconnect`

We can automatically connect to those endpoints simply by specifying the name of the role (`"user"`):


```javascript
// Browser code
const party = new Privateparty()
let session = await party.connect("user")
if (session) document.write("logged in: " + session.account)
```

##### 2. custom engine connection

if you've set up multiple engines on the backend side, you can connect to the custom endpoints by initializing the `Privateparty` object with custom endpoints.

For example let's take an example with multiple roles ("user" and "admin"):

```javascript
const party = new Privateparty()

// "user" role
party.add("user")

// "admin" role
party.add("admin", {
  session: "/privateparty/admin/session",
  connect: "/privateparty/admin/connect",
  disconnect: "/privateparty/admin/disconnect",
  authorize: (req, account) => {
    const ADMIN = "0x502b2FE7Cc3488fcfF2E16158615AF87b4Ab5C41"
    if (account === ADMIN) {
      return { admin: true }
    } else {
      throw new Error("Not an admin")
    }
  }
})

// User UI
party.app.get("/", party.auth("user"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/index.html")
})

// Admin UI
party.app.get("/admin", party.auth("admin"), (req, res) => {
  console.log("session", req.session)
  res.sendFile(process.cwd() + "/admin.html")
})
party.app.listen(3000)
```

Now, from the browser, lets try to login as admin:

```javascript
const party = new Privateparty()
let session = await party.connect("admin")
```

The `party.connect("admin")`:

1. automatically discovers the `/admin/connect` endpoint
2. makes a POST request to it
3. the `authorize()` callback in the backend takes care of the authorization for the admin role

##### 3. authenticate with custom payload

Often, the authorization logic may require more than just the user account. For example, the user may authenticate with a specific NFT (`tokenId` and `contract`), in which case the frontend needs to pass more data to the Privateparty server. Here's an example:

```javascript
const party = new Privateparty()
await party.connect("user", {
  contract: "0x6866ed9a183f491024692971a8f78b048fb6b89b",
  tokenId: "55005454344647406361450320675654878134478584534017520891306338141495783002503"
})
```

The server may implement an `authorize(req, account)` function in the engine that looks like this:

```javascript
const Privateparty = require('privateparty')
const { createAlchemyWeb3 } = require("@alch/alchemy-web3");
const web3 = createAlchemyWeb3(<YOUR JSON-RPC ENDPOINT URL>)
const party = new Privateparty()
const { app, express, auth } = new Privateparty({
  engines: {
    user: {
      authorize: async (req, account) => {
        const collection = req.body.auth.contract
        const tokenId = req.body.auth.tokenId
        const abi = [{
          "inputs": [{ "internalType": "uint256", "name": "tokenId", "type": "uint256" }],
          "name": "ownerOf",
          "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
          "stateMutability": "view",
          "type": "function"
        }]
        let contract = new web3.eth.Contract(abi, collection)

        // allow login ONLY if the current account owns the tokenId
        let owner = await contract.methods.ownerOf(tokenId).call()
        if (owner.toLowerCase() === account.toLowerCase()) {
          return { tokenId, collection }
        } else {
          throw new Error("the user is not the token owner")
        }
      }
    }
  }
})
```

Note that the additional payload is included under the attribute `req.body.auth`.

##### 4. let users select an account from the wallet

By default, Privateparty automatically uses the default account. But sometimes you may want to let the user select another account from the wallet.

To connect this way, you can:

```javascript
const party = new Privateparty()
await party.connect("user", null, { fresh: true })
```

Note:

- The second argument is `null` (we are not passing any payload)
- The third argument (`options`) of the `connect()` method is `{fresh: true}`. This tells privateparty to make a fresh connection, which lets the user select from all the accounts in the wallet instead of the default one.

Of course, you can do this while passing a payload too:

```javascript
const party = new Privateparty()
await party.connect(
  "user",
  { contract: "0x6866ed9a183f491024692971a8f78b048fb6b89b", tokenId: "55005454344647406361450320675654878134478584534017520891306338141495783002503" },
  { fresh: true }
)
```

Now the second argument is the `payload`, and the third argument is the `options`

---

### session()

The `session()` method is used to get the current session.

#### syntax

```javascript
let session = await party.session(name)
```

#### parameters

- `name`: The name of the role for the session

#### return value

- `session`: the global session object for the specified name
  - `account`: the authenticated account
  - `expiresIn`: how long this session will be valid for since the issued time (`iat`), in seconds. (default: 60 * 60 * 24 * 30, or 30 days)
  - `iat`: when this session was issued
  - `auth`: **(optional)** additional attributes set by the privateparty server if needed. Only included when you return something from the `authorize()` callback when calling `party.add()`.


#### examples

```javascript
let session = await party.session("user")
console.log(session)
// The session may look something like:
//
//  {
//    account: "0x502b2FE7Cc3488fcfF2E16158615AF87b4Ab5C41",
//    auth: {
//      collection: "0x6866ed9a183f491024692971a8f78b048fb6b89b",
//      tokenId: "55005454344647406361450320675654878134478584534017520891306338141495783002503"
//    }
//  }


let admin_session = await party.session("admin")
console.log(admin_session)
// The admin_session may look something like:
//
//  {
//    account: "0x502b2FE7Cc3488fcfF2E16158615AF87b4Ab5C41",
//    auth: {
//      admin: true
//    }
//  }
//
```

---

### disconnect()

Clears the cookies and logs out of all sessions

#### syntax

```javascript
await party.disconnect(name)
```

#### parameters

- `name`: The name of the session to disconnect from

#### return value

- none


---

## Node.js client

Privateparty utilizes [JWT](https://en.wikipedia.org/wiki/JSON_Web_Token), which means you can take the same session created from the browser, and use it in a server setting, or any other non-browser setting.

Here's how the node.js client differ from the browser client:

1. No cookie: Unlike the partyconnect browser client, which takes care of setting cookies automatically after the connection, the `partypass` node.js client simply makes a request to the privateparty server to create a JWT token. From that point on, it's up to you what to do with the JWT token.
2. Use private key directly: The `partyconnect` browser client was built for a seamless in-browser usage, therefore uses whatever wallet is injected into the browser. But the `partypass` node.js client is primarily supposed to run in node.js setting, and there is no injected browser wallet. Therefore, to initialize `partypass` you must pass a private key, which will be used to sign messages.

Basically, the `partyconnect` library is primarily for in-browser usage, whereas `partypass` is a super minimal library for creating JWTs, using a private key you provided.

### constructor

#### syntax

```javascript
const pass = new Partypass(config)
```

#### parameters

- `config`
  - `host`: The privateparty host URL
  - `key`: The private key in hex form (without a `0x` prefix)

#### return value

- `pass`: an initialized partypass object, which can be used to create sessions

#### example

```javascript
const pass = new Partypass({
  host: "http://localhost:3000",
  key: "cd76c32ffeae94b725b40b1f58ffc793d5b0e96596f8d067f29d385894f16424" // private key
})
```

In most cases you do NOT want to hardcode private keys, so the code may actually look something like:

```javascript
const pass = new Partypass({
  host: "http://localhost:3000",
  key: process.env.PRIVATE_KEY  // use environment variables
})
```

### create()

Create a session using the initialized Partypass object

> `await pass.create(name, payload)` is equivalent to `await pass.request(await pass.build(name), payload)`

#### syntax

```javascript
const session = await pass.create(name, payload)
```

#### parameters

- `name`: the name of a privateparty role. Automatically connects to the endpoints defined on the privateparty backend with the same name.
- `payload`: **(optional)** additional payload that will be passed to the Privateparty server. The Privateparty server will be able to inspect `req.body.payload` in its authorization logic.

#### return value

- `session`: The authenticated and authorized session object for this connection.
  - `account`: the authenticated account
  - `expiresIn`: how long this session will be valid for since the issued time (`iat`), in seconds. (default: 60 * 60 * 24 * 30, or 30 days)
  - `jwt`: the full JWT string
  - `auth`: **(optional)** additional attributes set by the privateparty server if needed. Only included when you return something from the `authorize()` callback when calling `party.add()`.

The same `session` object will be stored inside the cookie and will be accessible subsequently via `party.session()`

#### examples

Let's assume the Privateparty backend has added a role named "user":

```javascript
// server.js
const party = new Privateparty()
party.add("user")
party.app.get("/", party.auth("user"), (req, res) => {
  // public route.
  // no authentication and no authorization
})
party.app.listen(3000)
```

Now create a client that will make a request to above privateparty server, as `client.js`:

```javascript
// client.js
const Partypass = require('partypass')
const pass = new Partypass({
  host: "http://localhost:3000",
  key: "cd76c32ffeae94b725b40b1f58ffc793d5b0e96596f8d067f29d385894f16424" // replace with your private key
})
let session = await pass.create("user")
console.log(session)
```

and run `node client`. You will get a session object with a JWT included.


### session()

check if the session has expired or not

#### syntax

```javascript
const session = await pass.session(name)
```

#### parameters

- `name`: the name of the role

#### return value

- `session`: returns the session info for the `name` role. If expired, returns `null`.


### build()

build a signed request to send to a privateparty server.

> a `create()` call is equivalent to calling `build()` and then calling `request()` 

#### syntax

```javascript
const req = await pass.build(name)
```

#### parameters

- `name`: the name of the role

#### return value

- `req`: the prepared request object. This can be sent to the associated privateparty server (must be the same host as the connected `host`)
  - `str`: the nonce message that was signed
  - `sig`: the signature (personal signature)
  - `url`: the endpoint to send the request to


### request()

send a built request created with the `build()` method to get the corresponding session back from the privateparty server

#### syntax

```javascript
const session = await pass.request(req, payload)
```

#### parameters

- `req`: the prepared request object created with `pass.build()`. This can be sent to the associated privateparty server (must be the same host as the connected `host`)
  - `str`: the nonce message that was signed
  - `sig`: the signature (personal signature)
  - `url`: the endpoint to send the request to
- `payload`: **(optional)** an extra payload to send to the privateparty server.

#### return value

- `session`: returns the created session info for the `name` role.
  - `account`: the authenticated account
  - `expiresIn`: how long this session will be valid for since the issued time (`iat`), in seconds. (default: 60 * 60 * 24 * 30, or 30 days)
  - `jwt`: the full JWT string
  - `auth`: **(optional)** additional attributes set by the privateparty server if needed. Only included when you return something from the `authorize()` callback when calling `party.add()`.
